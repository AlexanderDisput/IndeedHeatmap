<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Intent Quadrant</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg: #edf4ff;
        --surface: #ffffff;
        --ink: #122235;
        --muted: #4e647c;
        --line: #d6e2f2;
        --brand: #1f6fb2;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Sora", "Avenir Next", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 10% 12%, #dce9ff 0%, transparent 35%),
          radial-gradient(circle at 85% 88%, #d9f0ff 0%, transparent 30%),
          var(--bg);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 8px;
      }

      h1,
      h2,
      h3 {
        margin: 0 0 10px;
      }

      .upload {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .upload label {
        font-weight: 600;
      }

      .hint {
        color: var(--muted);
        margin: 0 0 14px;
      }

      .benchmark-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 0;
        align-items: center;
      }

      .benchmark-panel {
        margin: 14px 0 12px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #f8fbff;
        padding: 10px;
      }

      .benchmark-title {
        margin: 0 0 8px;
        font-size: 12px;
        font-weight: 700;
        color: var(--brand);
      }

      .benchmark-controls label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
      }

      .benchmark-field {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .benchmark-controls input {
        width: 88px;
        margin-left: 6px;
        border: 1px solid #003A9B;
        border-radius: 8px;
        padding: 6px 8px;
        font: inherit;
        font-size: 13px;
      }

      .benchmark-controls input:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 58, 155, 0.2);
      }


      .error {
        color: #b91c1c;
        font-weight: 600;
        margin: 8px 0 14px;
      }

      .table-wrap {
        border: 1px solid var(--line);
        border-radius: 10px;
        overflow: auto;
        background: var(--surface);
        max-height: 340px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
      }

      thead {
        position: sticky;
        top: 0;
        background: #eef5ff;
        z-index: 1;
      }

      th,
      td {
        border-bottom: 1px solid var(--line);
        white-space: nowrap;
        text-align: left;
        font-size: 13px;
        padding: 8px 10px;
      }

      .th-sort-btn {
        appearance: none;
        border: 1px solid #002a70;
        background: #003A9B;
        color: #ffffff;
        border-radius: 8px;
        padding: 4px 8px;
        font: inherit;
        font-size: 12px;
        font-weight: 700;
        cursor: pointer;
      }

      .th-sort-btn:hover {
        background: #002f82;
        box-shadow: 0 4px 10px rgba(18, 34, 53, 0.16);
      }

      .quadrant-shell {
        margin-top: 16px;
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
        background: var(--surface);
      }

      #chart {
        width: 100%;
        height: auto;
        display: block;
        background: linear-gradient(180deg, #fbfdff, #f3f8ff);
        border-radius: 8px;
      }

      .tiles {
        margin-top: 16px;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 12px;
      }

      .tile {
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--surface);
        padding: 12px;
        position: relative;
      }

      .tile p {
        margin: 0 0 8px;
        font-size: 13px;
        color: var(--muted);
      }

      .tile-hint {
        font-size: 12px;
        color: #355275;
        font-weight: 600;
      }

      .tile-hover-tooltip {
        position: fixed;
        z-index: 1200;
        max-width: 380px;
        background: #ffffff;
        border: 1px solid var(--line);
        border-radius: 10px;
        box-shadow: 0 14px 32px rgba(18, 34, 53, 0.22);
        padding: 10px 12px;
        display: none;
        pointer-events: none;
      }

      .tile-hover-tooltip p {
        margin: 0 0 8px;
        font-size: 12px;
        color: #223449;
      }

      .tile-hover-tooltip ul {
        margin: 0;
        padding-left: 18px;
      }

      .tile-hover-tooltip li {
        font-size: 12px;
        color: #2a3d55;
        margin-bottom: 4px;
      }

      .count {
        font-size: 13px;
        margin-bottom: 8px;
      }

      .job-list {
        margin: 0 0 10px;
        padding-left: 18px;
        max-height: 130px;
        overflow: auto;
      }

      .job-list li {
        font-size: 13px;
        margin-bottom: 4px;
      }

      button.export {
        border: none;
        background: #003A9B;
        border: 1px solid #002a70;
        color: #fff;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        cursor: pointer;
      }

      button.export:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      .tooltip {
        position: fixed;
        pointer-events: none;
        background: rgba(8, 20, 40, 0.95);
        color: #fff;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        line-height: 1.35;
        display: none;
        max-width: 280px;
        z-index: 999;
      }

      .legend {
        margin: 8px 0 0;
        font-size: 13px;
        color: var(--muted);
      }

      .benchmark-note {
        margin: 0 0 8px;
        font-size: 12px;
        color: #33516e;
        font-weight: 700;
      }

      .benchmark-accent {
        color: #003A9B;
        font-weight: 800;
      }

      @media (max-width: 980px) {
        .tiles {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 768px) {
        main {
          padding: 8px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1 id="pageTitle">Job Intent Quadrant</h1>
      <div class="upload">
        <label id="uploadLabel" for="csvFile">Upload CSV</label>
        <input id="csvFile" type="file" accept=".csv" />
      </div>
      <p id="hintText" class="hint">
        Required columns: job, company name, CTR, and ASR. English, NL, DE, FR, IT, and ES header variants are supported.
      </p>
      <div id="error" class="error" hidden></div>

      <h2 id="jobsTitle">List of Jobs</h2>
      <div class="table-wrap">
        <table id="dataTable">
          <thead id="tableHead"></thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>

      <h2 id="quadrantTitle" style="margin-top: 16px">Intent Quadrant</h2>
      <section class="benchmark-panel">
        <p id="benchTitle" class="benchmark-title">Manual Benchmarks (Optional)</p>
        <div class="benchmark-controls">
          <div class="benchmark-field">
            <label id="ctrBenchLabel" for="ctrBenchmarkInput">CTR Benchmark (%)</label>
            <input id="ctrBenchmarkInput" type="number" min="0" step="0.1" />
          </div>
          <div class="benchmark-field">
            <label id="asrBenchLabel" for="asrBenchmarkInput">ASR Benchmark (%)</label>
            <input id="asrBenchmarkInput" type="number" min="0" step="0.1" />
          </div>
        </div>
      </section>

      <div class="quadrant-shell">
        <p id="benchmarkNotice" class="benchmark-note">Upload data to compute current medians.</p>
        <svg id="chart" viewBox="0 0 1000 620" aria-label="Intent Quadrant Chart"></svg>
        <p id="chartLegendText" class="legend">
          X-axis: Clickthrough intent (CTR), Y-axis: Apply start intent (ASR). Marker size and color are based on intent score = CTR * ASR.
          Dotted reference lines use manual benchmarks when provided; otherwise dataset medians are used.
        </p>
      </div>

      <h2 id="tilesTitle" style="margin-top: 16px">Action Tiles</h2>
      <section class="tiles" id="tiles"></section>
    </main>

    <div id="tooltip" class="tooltip"></div>
    <div id="tileHoverTooltip" class="tile-hover-tooltip"></div>

    <script>
      const columnAliases = {
        job: ["Job", "Vacature", "Stelle", "Emploi", "Annuncio", "Empleo"],
        company: [
          "Company name",
          "Bedrijfsnaam",
          "Unternehmensname",
          "Nom de l'entreprise",
          "Nome dell'azienda",
          "Nombre de la empresa"
        ],
        ctr: [
          "Click-through rate (CTR)",
          "Clickthrough rate (CTR)",
          "Click Through Rate (CTR)",
          "CTR",
          "Klikfrequentie (CTR)",
          "Klickrate (CTR)",
          "Taux de clics (CTR)",
          "Percentuale di click (CTR)",
          "Porcentaje de clics (CTR)"
        ],
        asr: [
          "Apply start rate (ASR)",
          "Apply Start Rate (ASR)",
          "ASR",
          "Percentage gestarte sollicitaties",
          "Rate begonnener Bewerbungen (ASR)",
          "Taux de candidatures commencees (ASR)",
          "Percentuale di candidature avviate",
          "Porcentaje de postulaciones iniciadas"
        ]
      };

      let ctrThreshold = 0;
      let asrThreshold = 0;
      let medianCtr = null;
      let medianAsr = null;

      const csvFile = document.getElementById("csvFile");
      const errorBox = document.getElementById("error");
      const tableHead = document.getElementById("tableHead");
      const tableBody = document.getElementById("tableBody");
      const chart = document.getElementById("chart");
      const tooltip = document.getElementById("tooltip");
      const tileHoverTooltip = document.getElementById("tileHoverTooltip");
      const tiles = document.getElementById("tiles");
      const benchmarkNotice = document.getElementById("benchmarkNotice");
      const uploadSection = document.querySelector(".upload");
      const ctrBenchmarkInput = document.getElementById("ctrBenchmarkInput");
      const asrBenchmarkInput = document.getElementById("asrBenchmarkInput");
      const embedded = new URLSearchParams(window.location.search).get("embedded") === "1";
      const SHARED_UPLOAD_MESSAGE = "shared-csv-upload";
      const UI_LANGUAGE_MESSAGE = "ui-language-changed";
      let currentLanguage = "en";
      const uiText = {
        en: { title: "Job Intent Quadrant", upload: "Upload CSV", hint: "Required columns: job, company name, CTR, and ASR. English, NL, DE, FR, IT, and ES header variants are supported.", jobs: "List of Jobs", quadrant: "Intent Quadrant", benchTitle: "Manual Benchmarks (Optional)", ctr: "CTR Benchmark (%)", asr: "ASR Benchmark (%)", applyBench: "Apply", legend: "X-axis: Clickthrough intent (CTR), Y-axis: Apply start intent (ASR). Marker size and color are based on intent score = CTR * ASR. Dotted reference lines use manual benchmarks when provided; otherwise dataset medians are used.", tiles: "Action Tiles", noticeDefault: "Upload data to compute current medians." },
        de: { title: "Job-Intent-Quadrant", upload: "CSV hochladen", hint: "Erforderliche Spalten: Job, Firmenname, CTR und ASR. EN/NL/DE/FR/IT/ES Varianten werden unterstützt.", jobs: "Jobliste", quadrant: "Intent-Quadrant", benchTitle: "Manuelle Benchmarks (optional)", ctr: "CTR-Benchmark (%)", asr: "ASR-Benchmark (%)", applyBench: "Anwenden", legend: "X-Achse: Klickintention (CTR), Y-Achse: Bewerbungsstart-Intention (ASR). Punktgröße und Farbe basieren auf CTR * ASR. Gepunktete Linien nutzen manuelle Benchmarks, sonst Mediane.", tiles: "Aktionskacheln", noticeDefault: "Daten hochladen, um Mediane zu berechnen." },
        fr: { title: "Quadrant d'intention des emplois", upload: "Importer CSV", hint: "Colonnes requises : job, nom d'entreprise, CTR et ASR. Variantes EN/NL/DE/FR/IT/ES prises en charge.", jobs: "Liste des emplois", quadrant: "Quadrant d'intention", benchTitle: "Benchmarks manuels (optionnel)", ctr: "Benchmark CTR (%)", asr: "Benchmark ASR (%)", applyBench: "Appliquer", legend: "Axe X : intention de clic (CTR), axe Y : intention de démarrage (ASR). Taille et couleur selon CTR * ASR. Les lignes pointillées utilisent les benchmarks manuels, sinon les médianes.", tiles: "Tuiles d'action", noticeDefault: "Importez des données pour calculer les médianes." },
        es: { title: "Cuadrante de intención de empleo", upload: "Subir CSV", hint: "Columnas requeridas: empleo, empresa, CTR y ASR. Se admiten variantes EN/NL/DE/FR/IT/ES.", jobs: "Lista de empleos", quadrant: "Cuadrante de intención", benchTitle: "Benchmarks manuales (opcional)", ctr: "Benchmark CTR (%)", asr: "Benchmark ASR (%)", applyBench: "Aplicar", legend: "Eje X: intención de clic (CTR), eje Y: intención de inicio (ASR). Tamaño y color por CTR * ASR. Las líneas punteadas usan benchmarks manuales; si no, medianas.", tiles: "Bloques de acción", noticeDefault: "Sube datos para calcular medianas." },
        it: { title: "Quadrante di intenzione lavoro", upload: "Carica CSV", hint: "Colonne richieste: lavoro, azienda, CTR e ASR. Supportate varianti EN/NL/DE/FR/IT/ES.", jobs: "Elenco lavori", quadrant: "Quadrante intenzione", benchTitle: "Benchmark manuali (opzionale)", ctr: "Benchmark CTR (%)", asr: "Benchmark ASR (%)", applyBench: "Applica", legend: "Asse X: intenzione click (CTR), asse Y: intenzione avvio candidatura (ASR). Dimensione e colore su CTR * ASR. Le linee tratteggiate usano benchmark manuali, altrimenti mediane.", tiles: "Riquadri azione", noticeDefault: "Carica dati per calcolare le mediane." },
        nl: { title: "Job intent-kwadrant", upload: "CSV uploaden", hint: "Vereiste kolommen: job, bedrijfsnaam, CTR en ASR. EN/NL/DE/FR/IT/ES-varianten worden ondersteund.", jobs: "Lijst met vacatures", quadrant: "Intentie-kwadrant", benchTitle: "Handmatige benchmarks (optioneel)", ctr: "CTR-benchmark (%)", asr: "ASR-benchmark (%)", applyBench: "Toepassen", legend: "X-as: klikintentie (CTR), Y-as: sollicitatiestart-intentie (ASR). Grootte en kleur op basis van CTR * ASR. Gestippelde lijnen gebruiken handmatige benchmarks, anders medianen.", tiles: "Actietegels", noticeDefault: "Upload data om medianen te berekenen." }
      };
      const localizedTableHeaders = {
        en: { job: "Job", company: "Company", ctr: "CTR", asr: "ASR", city: "City", country: "Country", impressions: "Impressions", clicks: "Clicks", applications: "Applications", applystarts: "Apply starts", spend: "Spend", cpa: "CPA", cpas: "CPAS", campaign: "Campaign", status: "Status", reference: "Reference" },
        de: { job: "Job", company: "Unternehmen", ctr: "CTR", asr: "ASR", city: "Stadt", country: "Land", impressions: "Impressionen", clicks: "Klicks", applications: "Bewerbungen", applystarts: "Bewerbungsstarts", spend: "Ausgaben", cpa: "CPA", cpas: "CPAS", campaign: "Kampagne", status: "Status", reference: "Referenz" },
        fr: { job: "Poste", company: "Entreprise", ctr: "CTR", asr: "ASR", city: "Ville", country: "Pays", impressions: "Impressions", clicks: "Clics", applications: "Candidatures", applystarts: "Débuts de candidature", spend: "Dépenses", cpa: "CPA", cpas: "CPAS", campaign: "Campagne", status: "Statut", reference: "Référence" },
        es: { job: "Puesto", company: "Empresa", ctr: "CTR", asr: "ASR", city: "Ciudad", country: "País", impressions: "Impresiones", clicks: "Clics", applications: "Solicitudes", applystarts: "Inicios de solicitud", spend: "Gasto", cpa: "CPA", cpas: "CPAS", campaign: "Campaña", status: "Estado", reference: "Referencia" },
        it: { job: "Ruolo", company: "Azienda", ctr: "CTR", asr: "ASR", city: "Città", country: "Paese", impressions: "Impression", clicks: "Clic", applications: "Candidature", applystarts: "Avvii candidatura", spend: "Spesa", cpa: "CPA", cpas: "CPAS", campaign: "Campagna", status: "Stato", reference: "Riferimento" },
        nl: { job: "Vacature", company: "Bedrijf", ctr: "CTR", asr: "ASR", city: "Plaats", country: "Land", impressions: "Impressies", clicks: "Klikken", applications: "Sollicitaties", applystarts: "Gestarte sollicitaties", spend: "Uitgaven", cpa: "CPA", cpas: "CPAS", campaign: "Campagne", status: "Status", reference: "Referentie" }
      };
      const tileText = {
        en: {
          hoverHint: "Hover for interpretation and possible drivers.",
          highTitle: "High CTR, Low ASR",
          highInterpretation: "Interpretation: Attraction works. Commitment fails.",
          highDrivers: [
            "Expectation mismatch (title vs. actual scope)",
            "Compensation misalignment (below market or unclear range)",
            "Location / work model friction (onsite, hybrid ambiguity, travel)",
            "Requirement inflation (too many or unrealistic must-haves)",
            "Role ambiguity (unclear outcomes, reporting line, growth path)",
            "Employer trust gap (weak brand, low differentiation, low credibility)",
            "Seniority inconsistency (title vs. responsibility mismatch)",
            "Posting fatigue (role aged or repeatedly reposted)"
          ],
          lowHighTitle: "Low CTR, High ASR",
          lowHighInterpretation: "Interpretation: Strong conversion once discovered. Visibility and relevance in search are limiting performance.",
          lowHighDrivers: [
            "Title not aligned with common market search terms",
            "Overly internal or branded job titles",
            "Missing high-volume keywords in title or first lines",
            "Seniority not clearly signaled (Junior, Senior, Lead, etc.)",
            "Location formatting reducing search eligibility",
            "Narrow or overly specific phrasing limiting match breadth",
            "Low budget / limited distribution (if sponsored)",
            "Competitive search saturation in that job category"
          ],
          lowLowTitle: "Low CTR, Low ASR",
          lowLowRecommendation: "Relevance issue across both stages. Rework title, keywords, and core value proposition.",
          jobsInTile: "jobs in this tile",
          noJobs: "No jobs in this tile.",
          unknownJob: "Unknown job",
          export: "Export CSV"
        },
        de: {
          hoverHint: "Für Interpretation und mögliche Treiber hovern.",
          highTitle: "Hohe CTR, niedrige ASR",
          highInterpretation: "Interpretation: Aufmerksamkeit funktioniert. Verbindlichkeit scheitert.",
          highDrivers: [
            "Erwartungsmismatch (Titel vs. tatsächlicher Umfang)",
            "Vergütungsmismatch (unter Markt oder unklare Spanne)",
            "Standort-/Arbeitsmodell-Reibung (onsite, Hybrid-Unklarheit, Reiseanteil)",
            "Anforderungsinflation (zu viele oder unrealistische Must-haves)",
            "Rollenunklarheit (Ergebnisse, Berichtslinie, Entwicklungspfad)",
            "Arbeitgeber-Vertrauenslücke (schwache Marke, geringe Differenzierung, geringe Glaubwürdigkeit)",
            "Senioritätsinkonsistenz (Titel passt nicht zur Verantwortung)",
            "Posting-Müdigkeit (Rolle alt oder wiederholt repostet)"
          ],
          lowHighTitle: "Niedrige CTR, hohe ASR",
          lowHighInterpretation: "Interpretation: Starke Conversion, sobald entdeckt. Sichtbarkeit und Suchrelevanz begrenzen die Performance.",
          lowHighDrivers: [
            "Titel nicht an gängige Suchbegriffe im Markt angepasst",
            "Zu interne oder markenspezifische Jobtitel",
            "Fehlende Keywords mit hohem Suchvolumen im Titel oder in den ersten Zeilen",
            "Seniorität nicht klar signalisiert (Junior, Senior, Lead usw.)",
            "Standortformatierung reduziert Suchsichtbarkeit",
            "Zu enge oder zu spezifische Formulierung begrenzt Reichweite",
            "Niedriges Budget / begrenzte Distribution (bei Sponsored)",
            "Hohe Wettbewerbssättigung in dieser Jobkategorie"
          ],
          lowLowTitle: "Niedrige CTR, niedrige ASR",
          lowLowRecommendation: "Relevanzproblem in beiden Stufen. Titel, Keywords und Kernbotschaft überarbeiten.",
          jobsInTile: "Jobs in dieser Kachel",
          noJobs: "Keine Jobs in dieser Kachel.",
          unknownJob: "Unbekannter Job",
          export: "CSV exportieren"
        },
        fr: {
          hoverHint: "Survolez pour l'interprétation et les facteurs possibles.",
          highTitle: "CTR élevée, ASR faible",
          highInterpretation: "Interprétation : l'attraction fonctionne. L'engagement échoue.",
          highDrivers: [
            "Décalage d'attentes (intitulé vs périmètre réel)",
            "Décalage de rémunération (sous le marché ou fourchette floue)",
            "Friction lieu/modèle de travail (sur site, ambiguïté hybride, déplacements)",
            "Inflation des exigences (trop de prérequis ou irréalistes)",
            "Ambiguïté du rôle (résultats, rattachement, progression)",
            "Manque de confiance envers l'employeur (marque faible, faible différenciation, crédibilité faible)",
            "Incohérence de séniorité (intitulé vs responsabilités)",
            "Fatigue de publication (annonce ancienne ou repostée)"
          ],
          lowHighTitle: "CTR faible, ASR élevée",
          lowHighInterpretation: "Interprétation : forte conversion une fois trouvé. La visibilité et la pertinence en recherche limitent la performance.",
          lowHighDrivers: [
            "Titre non aligné avec les termes de recherche du marché",
            "Titres trop internes ou trop marqués marque",
            "Mots-clés à fort volume absents du titre ou des premières lignes",
            "Séniorité non clairement signalée (Junior, Senior, Lead, etc.)",
            "Format de localisation réduisant l'éligibilité en recherche",
            "Formulation trop étroite ou trop spécifique limitant la portée",
            "Budget faible / diffusion limitée (si sponsorisé)",
            "Forte saturation concurrentielle sur cette catégorie"
          ],
          lowLowTitle: "CTR faible, ASR faible",
          lowLowRecommendation: "Problème de pertinence aux deux étapes. Revoir intitulé, mots-clés et proposition de valeur.",
          jobsInTile: "emplois dans cette tuile",
          noJobs: "Aucun emploi dans cette tuile.",
          unknownJob: "Emploi inconnu",
          export: "Exporter CSV"
        },
        es: {
          hoverHint: "Pasa el cursor para ver interpretación y posibles causas.",
          highTitle: "CTR alto, ASR bajo",
          highInterpretation: "Interpretación: La atracción funciona. El compromiso falla.",
          highDrivers: [
            "Desajuste de expectativas (título vs alcance real)",
            "Desajuste de compensación (por debajo del mercado o rango poco claro)",
            "Fricción por ubicación/modelo de trabajo (presencial, ambigüedad híbrida, viajes)",
            "Inflación de requisitos (demasiados o poco realistas)",
            "Ambigüedad del rol (resultados, línea de reporte, crecimiento)",
            "Brecha de confianza en la empresa (marca débil, baja diferenciación, baja credibilidad)",
            "Inconsistencia de seniority (título vs responsabilidad)",
            "Fatiga de publicación (vacante antigua o republicada)"
          ],
          lowHighTitle: "CTR bajo, ASR alto",
          lowHighInterpretation: "Interpretación: Conversión fuerte una vez descubierto. La visibilidad y relevancia en búsqueda limitan el rendimiento.",
          lowHighDrivers: [
            "Título no alineado con términos de búsqueda comunes del mercado",
            "Títulos demasiado internos o de marca",
            "Faltan keywords de alto volumen en el título o primeras líneas",
            "Seniority no indicado con claridad (Junior, Senior, Lead, etc.)",
            "Formato de ubicación que reduce elegibilidad en búsqueda",
            "Redacción demasiado estrecha o específica que limita alcance",
            "Presupuesto bajo / distribución limitada (si es patrocinado)",
            "Alta saturación competitiva en esa categoría"
          ],
          lowLowTitle: "CTR bajo, ASR bajo",
          lowLowRecommendation: "Problema de relevancia en ambas etapas. Revisa título, keywords y propuesta de valor.",
          jobsInTile: "empleos en este bloque",
          noJobs: "No hay empleos en este bloque.",
          unknownJob: "Empleo desconocido",
          export: "Exportar CSV"
        },
        it: {
          hoverHint: "Passa il mouse per interpretazione e possibili fattori.",
          highTitle: "CTR alto, ASR basso",
          highInterpretation: "Interpretazione: l'attrazione funziona. L'impegno fallisce.",
          highDrivers: [
            "Mismatch di aspettative (titolo vs reale ambito)",
            "Mismatch retributivo (sotto mercato o range poco chiaro)",
            "Friction su sede/modello di lavoro (onsite, ambiguità ibrido, trasferte)",
            "Inflazione requisiti (troppi o irrealistici)",
            "Ambiguità del ruolo (outcome, riporto, crescita)",
            "Gap di fiducia nel datore (brand debole, bassa differenziazione, scarsa credibilità)",
            "Incoerenza di seniority (titolo vs responsabilità)",
            "Stanchezza del posting (ruolo vecchio o ripubblicato)"
          ],
          lowHighTitle: "CTR basso, ASR alto",
          lowHighInterpretation: "Interpretazione: conversione forte una volta scoperto. Visibilità e rilevanza in ricerca limitano le performance.",
          lowHighDrivers: [
            "Titolo non allineato ai termini di ricerca più usati sul mercato",
            "Titoli troppo interni o brandizzati",
            "Mancano keyword ad alto volume nel titolo o nelle prime righe",
            "Seniority non chiaramente indicata (Junior, Senior, Lead, ecc.)",
            "Formato della location che riduce l'idoneità in ricerca",
            "Formulazione troppo stretta o specifica che limita la copertura",
            "Budget basso / distribuzione limitata (se sponsorizzato)",
            "Elevata saturazione competitiva in quella categoria"
          ],
          lowLowTitle: "CTR basso, ASR basso",
          lowLowRecommendation: "Problema di rilevanza in entrambe le fasi. Rivedere titolo, keyword e proposta di valore.",
          jobsInTile: "lavori in questo riquadro",
          noJobs: "Nessun lavoro in questo riquadro.",
          unknownJob: "Lavoro sconosciuto",
          export: "Esporta CSV"
        },
        nl: {
          hoverHint: "Hover voor interpretatie en mogelijke oorzaken.",
          highTitle: "Hoge CTR, lage ASR",
          highInterpretation: "Interpretatie: Aantrekkingskracht werkt. Commitment faalt.",
          highDrivers: [
            "Mismatch in verwachting (titel vs daadwerkelijke scope)",
            "Mismatch in beloning (onder markt of onduidelijke range)",
            "Wrijving in locatie/werkmodel (onsite, onduidelijk hybride, reizen)",
            "Eiseninflatie (te veel of onrealistische must-haves)",
            "Rol-ambiguïteit (uitkomsten, rapportagelijn, groeipad)",
            "Vertrouwensgat in werkgever (zwak merk, lage differentiatie, lage geloofwaardigheid)",
            "Senioriteitsinconsistentie (titel vs verantwoordelijkheid)",
            "Posting-moeheid (rol oud of herhaald geplaatst)"
          ],
          lowHighTitle: "Lage CTR, hoge ASR",
          lowHighInterpretation: "Interpretatie: Sterke conversie zodra gevonden. Zichtbaarheid en zoekrelevantie beperken de performance.",
          lowHighDrivers: [
            "Titel niet afgestemd op gangbare zoektermen in de markt",
            "Te interne of gebrandde functietitels",
            "Ontbrekende hoogvolume-keywords in titel of eerste regels",
            "Senioriteit niet duidelijk aangegeven (Junior, Senior, Lead, etc.)",
            "Locatie-opmaak verlaagt zoekgeschiktheid",
            "Te smalle of te specifieke formulering beperkt bereik",
            "Laag budget / beperkte distributie (bij gesponsord)",
            "Hoge concurrentieverzadiging in die jobcategorie"
          ],
          lowLowTitle: "Lage CTR, lage ASR",
          lowLowRecommendation: "Relevantieprobleem in beide fasen. Herwerk titel, keywords en waardepropositie.",
          jobsInTile: "jobs in deze tegel",
          noJobs: "Geen jobs in deze tegel.",
          unknownJob: "Onbekende job",
          export: "CSV exporteren"
        }
      };

      let currentHeaders = [];
      let currentRows = [];
      let currentJobHeader = null;
      let currentCompanyHeader = null;
      let currentCtrHeader = null;
      let currentAsrHeader = null;
      let tableSort = { key: null, dir: "asc" };

      function applyUiLanguage(lang) {
        currentLanguage = uiText[lang] ? lang : "en";
        const t = uiText[currentLanguage] || uiText.en;
        const set = (id, value) => {
          const el = document.getElementById(id);
          if (el) el.textContent = value;
        };
        set("pageTitle", t.title);
        set("uploadLabel", t.upload);
        set("hintText", t.hint);
        set("jobsTitle", t.jobs);
        set("quadrantTitle", t.quadrant);
        set("benchTitle", t.benchTitle);
        set("ctrBenchLabel", t.ctr);
        set("asrBenchLabel", t.asr);
        set("chartLegendText", t.legend);
        set("tilesTitle", t.tiles);
        if (!currentRows.length) set("benchmarkNotice", t.noticeDefault);
        if (currentHeaders.length) renderTable(currentHeaders, currentRows);
        if (currentRows.length) rerenderCurrentData();
      }

      async function applyCsvText(text) {
        try {
          hideError();
          const rows = parseCSV(text.replace(/^\uFEFF/, ""));
          if (!rows.length) throw new Error("CSV is empty.");

          const headers = rows[0];
          const jobHeader = pickHeader(headers, columnAliases.job);
          const companyHeader = pickHeader(headers, columnAliases.company);
          if (!jobHeader || !companyHeader) {
            throw new Error(
              "Missing required columns for Job and Company name. Supported header variants include EN/NL/DE/FR/IT/ES."
            );
          }

          const ctrHeader = pickHeader(headers, columnAliases.ctr);
          const asrHeader = pickHeader(headers, columnAliases.asr);
          if (!ctrHeader || !asrHeader) {
            throw new Error(
              "Missing required rate columns. Supported CTR/ASR header variants include EN/NL/DE/FR/IT/ES."
            );
          }

          const dataRows = rows.slice(1).map((r) => {
            const obj = {};
            headers.forEach((h, i) => {
              obj[h] = r[i] ?? "";
            });
            return obj;
          });

          currentHeaders = headers.slice();
          currentRows = dataRows;
          tableSort = { key: null, dir: "asc" };
          renderTable(currentHeaders, currentRows);
          currentJobHeader = jobHeader;
          currentCompanyHeader = companyHeader;
          currentCtrHeader = ctrHeader;
          currentAsrHeader = asrHeader;
          rerenderCurrentData();
        } catch (err) {
          showError(err.message || "Failed to parse CSV.");
          currentHeaders = [];
          currentRows = [];
          currentJobHeader = null;
          currentCompanyHeader = null;
          currentCtrHeader = null;
          currentAsrHeader = null;
          benchmarkNotice.textContent = (uiText[currentLanguage] || uiText.en).noticeDefault;
          renderTable([], []);
          clearQuadrant();
          tiles.innerHTML = "";
        }
      }

      csvFile.addEventListener("change", async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        const text = await file.text();
        await applyCsvText(text);
      });

      if (embedded && uploadSection) {
        uploadSection.style.display = "none";
      }

      window.addEventListener("message", async (event) => {
        const data = event.data;
        if (!data) return;
        if (data.type === SHARED_UPLOAD_MESSAGE && data.payload && data.payload.text) {
          await applyCsvText(data.payload.text);
          return;
        }
        if (data.type === UI_LANGUAGE_MESSAGE && data.payload && data.payload.language) {
          applyUiLanguage(data.payload.language);
        }
      });

      function rerenderCurrentData() {
        if (!currentRows.length || !currentJobHeader || !currentCompanyHeader || !currentCtrHeader || !currentAsrHeader) return;
        const rates = currentRows
          .map((row) => ({ ctr: parseRate(row[currentCtrHeader]), asr: parseRate(row[currentAsrHeader]) }))
          .filter((r) => r.ctr != null && r.asr != null);
        const ctrValues = rates.map((r) => r.ctr);
        const asrValues = rates.map((r) => r.asr);
        medianCtr = median(ctrValues);
        medianAsr = median(asrValues);

        const manualCtr = parseBenchmarkInput(ctrBenchmarkInput.value);
        const manualAsr = parseBenchmarkInput(asrBenchmarkInput.value);
        ctrThreshold = manualCtr != null ? manualCtr : (medianCtr ?? 0);
        asrThreshold = manualAsr != null ? manualAsr : (medianAsr ?? 0);

        const modeLabel = manualCtr != null || manualAsr != null ? "manual/median mixed" : "median auto";
        benchmarkNotice.innerHTML = `Current medians: <span class="benchmark-accent">CTR ${pctLabel(medianCtr ?? 0)}</span>, <span class="benchmark-accent">ASR ${pctLabel(medianAsr ?? 0)}</span>. Active benchmark mode: ${escapeHTML(modeLabel)}.`;
        renderQuadrant(currentRows, currentCtrHeader, currentAsrHeader, currentCompanyHeader, currentJobHeader);
        renderTiles(currentHeaders, currentRows, currentCtrHeader, currentAsrHeader, currentCompanyHeader, currentJobHeader);
      }

      function parseBenchmarkInput(rawValue) {
        const text = String(rawValue ?? "").trim();
        if (!text) return null;
        const num = Number(text);
        if (!Number.isFinite(num) || num < 0) return null;
        return num / 100;
      }

      function applyBenchmarkInputs() {
        rerenderCurrentData();
      }

      ctrBenchmarkInput.addEventListener("input", applyBenchmarkInputs);
      asrBenchmarkInput.addEventListener("input", applyBenchmarkInputs);
      applyUiLanguage(currentLanguage);

      function showError(message) {
        errorBox.textContent = message;
        errorBox.hidden = false;
      }

      function hideError() {
        errorBox.hidden = true;
        errorBox.textContent = "";
      }

      function parseRate(value) {
        if (value == null) return null;
        const raw = String(value).trim();
        if (!raw) return null;

        const percent = raw.endsWith("%");
        const cleaned = raw.replace(/,/g, "").replace("%", "").trim();
        const n = Number(cleaned);
        if (!Number.isFinite(n)) return null;
        return percent ? n / 100 : n;
      }

      function classifyRows(rows, ctrHeader, asrHeader) {
        const groups = {
          highCtrLowAsr: [],
          lowCtrHighAsr: [],
          lowBoth: [],
        };

        rows.forEach((row) => {
          const ctr = parseRate(row[ctrHeader]);
          const asr = parseRate(row[asrHeader]);
          if (ctr == null || asr == null) return;

          if (ctr >= ctrThreshold && asr < asrThreshold) {
            groups.highCtrLowAsr.push(row);
          } else if (ctr < ctrThreshold && asr >= asrThreshold) {
            groups.lowCtrHighAsr.push(row);
          } else if (ctr < ctrThreshold && asr < asrThreshold) {
            groups.lowBoth.push(row);
          }
        });

        return groups;
      }

      function renderTiles(headers, rows, ctrHeader, asrHeader, companyHeader, jobHeader) {
        const groups = classifyRows(rows, ctrHeader, asrHeader);
        const tileI18n = tileText[currentLanguage] || tileText.en;
        const config = [
          {
            key: "highCtrLowAsr",
            title: tileI18n.highTitle,
            recommendation: tileI18n.hoverHint,
            hoverDetails: {
              interpretation: tileI18n.highInterpretation,
              drivers: tileI18n.highDrivers
            },
            filename: "high_ctr_low_asr_jobs.csv",
          },
          {
            key: "lowCtrHighAsr",
            title: tileI18n.lowHighTitle,
            recommendation: tileI18n.hoverHint,
            hoverDetails: {
              interpretation: tileI18n.lowHighInterpretation,
              drivers: tileI18n.lowHighDrivers
            },
            filename: "low_ctr_high_asr_jobs.csv",
          },
          {
            key: "lowBoth",
            title: tileI18n.lowLowTitle,
            recommendation: tileI18n.lowLowRecommendation,
            filename: "low_ctr_low_asr_jobs.csv",
          },
        ];

        tiles.innerHTML = "";

        config.forEach((item) => {
          const setRows = groups[item.key];
          const card = document.createElement("article");
          card.className = "tile";

          const sampleJobs = setRows.slice(0, 8).map((r) => {
            const job = r[jobHeader] || tileI18n.unknownJob;
            return `<li>${escapeHTML(job)}</li>`;
          });

          card.innerHTML = `
            <h3>${item.title}</h3>
            <p class="tile-hint">${item.recommendation}</p>
            <div class="count"><strong>${setRows.length}</strong> ${tileI18n.jobsInTile}</div>
            <ul class="job-list">${sampleJobs.join("") || `<li>${escapeHTML(tileI18n.noJobs)}</li>`}</ul>
            <button class="export" ${setRows.length ? "" : "disabled"}>${tileI18n.export}</button>
          `;

          const btn = card.querySelector("button.export");
          btn.addEventListener("click", () => {
            downloadCsv(item.filename, headers, setRows, item, tileI18n);
          });

          if (item.hoverDetails) {
            const hoverHtml = `
              <p><strong>${escapeHTML(item.hoverDetails.interpretation)}</strong></p>
              <ul>${item.hoverDetails.drivers.map((d) => `<li>${escapeHTML(d)}</li>`).join("")}</ul>
            `;
            const placeHover = (event) => {
              const pad = 16;
              const offset = 16;
              const rect = tileHoverTooltip.getBoundingClientRect();
              let x = event.clientX + offset;
              let y = event.clientY + offset;
              if (x + rect.width + pad > window.innerWidth) x = event.clientX - rect.width - offset;
              if (y + rect.height + pad > window.innerHeight) y = event.clientY - rect.height - offset;
              if (x < pad) x = pad;
              if (y < pad) y = pad;
              tileHoverTooltip.style.left = `${x}px`;
              tileHoverTooltip.style.top = `${y}px`;
            };
            card.addEventListener("mouseenter", (event) => {
              tileHoverTooltip.innerHTML = hoverHtml;
              tileHoverTooltip.style.display = "block";
              placeHover(event);
            });
            card.addEventListener("mousemove", placeHover);
            card.addEventListener("mouseleave", () => {
              tileHoverTooltip.style.display = "none";
            });
          }

          tiles.appendChild(card);
        });
      }

      function normalizeHeaderName(value) {
        return String(value || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z0-9]/g, "");
      }

      function getHeaderKey(header) {
        const normalized = normalizeHeaderName(header);
        if (columnAliases.job.some((h) => normalizeHeaderName(h) === normalized)) return "job";
        if (columnAliases.company.some((h) => normalizeHeaderName(h) === normalized)) return "company";
        if (columnAliases.ctr.some((h) => normalizeHeaderName(h) === normalized)) return "ctr";
        if (columnAliases.asr.some((h) => normalizeHeaderName(h) === normalized)) return "asr";
        if (normalized.includes("city") || normalized.includes("plaats") || normalized.includes("stadt") || normalized.includes("ville") || normalized.includes("citta") || normalized.includes("ciudad")) return "city";
        if (normalized.includes("country") || normalized.includes("land") || normalized.includes("pais") || normalized.includes("paese") || normalized.includes("pays")) return "country";
        if (normalized.includes("impression")) return "impressions";
        if (normalized === "clicks" || normalized === "clics" || normalized === "klicks") return "clicks";
        if (normalized.includes("application") || normalized.includes("applies") || normalized.includes("bewerbung") || normalized.includes("candidature") || normalized.includes("sollicit")) return "applications";
        if (normalized.includes("applystart") || normalized.includes("gestartesollicitaties") || normalized.includes("begonnenebewerbungen") || normalized.includes("postulacionesiniciadas")) return "applystarts";
        if (normalized.includes("spend") || normalized.includes("cost") || normalized.includes("depense") || normalized.includes("gasto") || normalized.includes("spesa") || normalized.includes("uitgav")) return "spend";
        if (normalized === "cpa" || normalized.includes("costperapply")) return "cpa";
        if (normalized === "cpas" || normalized.includes("costperapplystart")) return "cpas";
        if (normalized.includes("campaign")) return "campaign";
        if (normalized.includes("status")) return "status";
        if (normalized.includes("reference")) return "reference";
        return null;
      }

      function localizedHeaderLabel(header) {
        const key = getHeaderKey(header);
        if (!key) return header;
        const labels = localizedTableHeaders[currentLanguage] || localizedTableHeaders.en;
        return labels[key] || header;
      }

      function sortTableRows(rows) {
        if (!tableSort.key) return rows.slice();
        const dir = tableSort.dir === "asc" ? 1 : -1;
        return rows.slice().sort((a, b) => {
          const left = a[tableSort.key];
          const right = b[tableSort.key];
          const leftRate = parseRate(left);
          const rightRate = parseRate(right);
          if (leftRate != null && rightRate != null) return (leftRate - rightRate) * dir;
          const leftRaw = String(left ?? "").replace(/,/g, "");
          const rightRaw = String(right ?? "").replace(/,/g, "");
          const leftNum = Number(leftRaw);
          const rightNum = Number(rightRaw);
          if (Number.isFinite(leftNum) && Number.isFinite(rightNum)) return (leftNum - rightNum) * dir;
          return String(left ?? "").localeCompare(String(right ?? "")) * dir;
        });
      }

      function renderTable(headers, rows) {
        tableHead.innerHTML = "";
        tableBody.innerHTML = "";

        if (!headers.length) return;

        const tr = document.createElement("tr");
        headers.forEach((h) => {
          const th = document.createElement("th");
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "th-sort-btn";
          const arrow = tableSort.key === h ? (tableSort.dir === "asc" ? " ↑" : " ↓") : "";
          btn.textContent = `${localizedHeaderLabel(h)}${arrow}`;
          btn.addEventListener("click", () => {
            if (tableSort.key === h) {
              tableSort.dir = tableSort.dir === "asc" ? "desc" : "asc";
            } else {
              tableSort.key = h;
              tableSort.dir = "asc";
            }
            renderTable(currentHeaders, currentRows);
          });
          th.appendChild(btn);
          tr.appendChild(th);
        });
        tableHead.appendChild(tr);

        sortTableRows(rows).forEach((row) => {
          const bodyTr = document.createElement("tr");
          headers.forEach((h) => {
            const td = document.createElement("td");
            td.textContent = row[h] ?? "";
            bodyTr.appendChild(td);
          });
          tableBody.appendChild(bodyTr);
        });
      }

      function clearQuadrant() {
        chart.innerHTML = "";
      }

      function renderQuadrant(rows, ctrHeader, asrHeader, companyHeader, jobHeader) {
        clearQuadrant();

        const points = rows
          .map((row) => {
            const ctr = parseRate(row[ctrHeader]);
            const asr = parseRate(row[asrHeader]);
            if (ctr == null || asr == null) return null;
            return {
              company: row[companyHeader] || "",
              job: row[jobHeader] || "",
              ctr,
              asr,
              intent: ctr * asr,
            };
          })
          .filter(Boolean);

        if (!points.length) return;

        const W = 1000;
        const H = 620;
        const margin = { top: 30, right: 24, bottom: 60, left: 78 };
        const plotW = W - margin.left - margin.right;
        const plotH = H - margin.top - margin.bottom;

        const maxCtr = Math.max(ctrThreshold, ...points.map((p) => p.ctr));
        const maxAsr = Math.max(asrThreshold, ...points.map((p) => p.asr));
        const xMax = niceMax(maxCtr);
        const yMax = niceMax(maxAsr);

        const toX = (v) => margin.left + (v / xMax) * plotW;
        const toY = (v) => margin.top + plotH - (v / yMax) * plotH;

        const bg = svgEl("rect", {
          x: margin.left,
          y: margin.top,
          width: plotW,
          height: plotH,
          fill: "#f9fcff",
          stroke: "#dbe8f7",
        });
        chart.appendChild(bg);

        const midV = svgEl("line", {
          x1: toX(ctrThreshold),
          x2: toX(ctrThreshold),
          y1: margin.top,
          y2: margin.top + plotH,
          stroke: "#5a6a7a",
          "stroke-dasharray": "6 5",
          "stroke-width": "2",
        });
        chart.appendChild(midV);

        const midH = svgEl("line", {
          x1: margin.left,
          x2: margin.left + plotW,
          y1: toY(asrThreshold),
          y2: toY(asrThreshold),
          stroke: "#5a6a7a",
          "stroke-dasharray": "6 5",
          "stroke-width": "2",
        });
        chart.appendChild(midH);

        chart.appendChild(
          svgEl(
            "text",
            {
              x: toX(ctrThreshold) + 6,
              y: margin.top + 16,
              fill: "#334155",
              "font-size": "12",
            },
            `CTR benchmark ${pctLabel(ctrThreshold)}`
          )
        );

        chart.appendChild(
          svgEl(
            "text",
            {
              x: margin.left + 8,
              y: toY(asrThreshold) - 6,
              fill: "#334155",
              "font-size": "12",
            },
            `ASR benchmark ${pctLabel(asrThreshold)}`
          )
        );

        chart.appendChild(
          svgEl("line", {
            x1: margin.left,
            y1: margin.top + plotH,
            x2: margin.left + plotW,
            y2: margin.top + plotH,
            stroke: "#243447",
            "stroke-width": "2",
          })
        );

        chart.appendChild(
          svgEl("line", {
            x1: margin.left,
            y1: margin.top,
            x2: margin.left,
            y2: margin.top + plotH,
            stroke: "#243447",
            "stroke-width": "2",
          })
        );

        for (let i = 0; i <= 5; i += 1) {
          const xVal = (xMax / 5) * i;
          const yVal = (yMax / 5) * i;

          const x = toX(xVal);
          const y = toY(yVal);

          chart.appendChild(
            svgEl(
              "text",
              {
                x,
                y: margin.top + plotH + 22,
                fill: "#425466",
                "font-size": "12",
                "text-anchor": "middle",
              },
              pctLabel(xVal)
            )
          );

          chart.appendChild(
            svgEl(
              "text",
              {
                x: margin.left - 10,
                y: y + 4,
                fill: "#425466",
                "font-size": "12",
                "text-anchor": "end",
              },
              pctLabel(yVal)
            )
          );
        }

        chart.appendChild(
          svgEl(
            "text",
            {
              x: margin.left + plotW / 2,
              y: H - 12,
              fill: "#1f2d3d",
              "font-size": "14",
              "text-anchor": "middle",
            },
            "Clickthrough intent (CTR)"
          )
        );

        chart.appendChild(
          svgEl(
            "text",
            {
              x: 20,
              y: margin.top + plotH / 2,
              fill: "#1f2d3d",
              "font-size": "14",
              transform: `rotate(-90 20 ${margin.top + plotH / 2})`,
              "text-anchor": "middle",
            },
            "Apply start intent (ASR)"
          )
        );

        const maxIntent = Math.max(0.0001, ...points.map((p) => p.intent));

        points.forEach((p) => {
          const cx = toX(p.ctr);
          const cy = toY(p.asr);
          const r = 4 + (p.intent / maxIntent) * 14;

          const c = svgEl("circle", {
            cx,
            cy,
            r: String(r.toFixed(2)),
            fill: intentColor(p.intent / maxIntent),
            stroke: "#0d2538",
            "stroke-width": "1",
            opacity: "0.88",
            tabindex: "0",
          });

          const show = (evt) => {
            const x = evt.clientX + 12;
            const y = evt.clientY + 12;
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
            tooltip.innerHTML = `<strong>${escapeHTML(p.company)}</strong><br>${escapeHTML(p.job)}<br>CTR: ${pctLabel(p.ctr)}<br>ASR: ${pctLabel(p.asr)}<br>Intent: ${p.intent.toFixed(4)}`;
            tooltip.style.display = "block";
          };

          c.addEventListener("mousemove", show);
          c.addEventListener("mouseenter", show);
          c.addEventListener("mouseleave", () => {
            tooltip.style.display = "none";
          });

          chart.appendChild(c);
        });
      }

      function downloadCsv(filename, headers, rows, tileConfig = null, tileI18n = null) {
        const localizedHeaders = headers.map((h) => localizedHeaderLabel(h));
        const headerLine = localizedHeaders.map(csvEscape).join(",");
        const dataLines = rows.map((row) => headers.map((h) => csvEscape(row[h] ?? "")).join(","));
        const lines = [headerLine, ...dataLines];
        if (tileConfig) {
          const exportActionTexts = {
            highCtrLowAsr: `High CTR + Low ASR:

Interpretation: Attraction works. Commitment fails.
Goal: Reduce perceived risk and align expectations to increase apply intent.

Action Steps

1. Tighten Title Accuracy

Remove inflated seniority (e.g., “Manager” without direct reports).

Replace broad keywords with precise functional titles.

Align title with actual scope and compensation level.

2. Align First 5 Lines with Search Promise

Ensure responsibilities match what the title implies.

Clearly state core function, team context, and impact.

Avoid generic intros (e.g., “We are looking for a dynamic…”).

3. Surface Compensation & Contract Early

Add salary range (competitive and realistic).

Clarify bonus structure if applicable.

State contract type and working hours clearly.

4. Reduce Requirement Inflation

Limit must-haves to 5–7 essentials.

Move secondary skills to “nice-to-have.”

Remove unrealistic experience stacking.

5. Clarify Work Model & Logistics

Explicitly state remote/hybrid/onsite.

Clarify travel expectations.

Avoid multi-location ambiguity.

6. Increase Role Clarity

Add reporting line.

Define success metrics or first-year expectations.

Clarify growth path if applicable.

7. Strengthen Employer Credibility

Add concrete differentiators (growth stage, market position).

Include impact statements.

Reduce generic employer branding language.`,
            lowCtrHighAsr: `Low CTR + High ASR

Interpretation: Strong conversion once discovered. Visibility is limiting performance.
Goal: Expand qualified reach without damaging conversion quality.

Action Steps

1. Optimize Job Title for Market Search

Replace internal titles with market-standard equivalents.

Add searchable functional keywords.

Include seniority markers (Junior, Senior, Lead).

2. Strengthen Keyword Density Strategically

Include high-volume keywords naturally in first 200 words.

Mirror common candidate search terms.

Avoid overly niche phrasing.

3. Broaden Functional Framing (Carefully)

Replace narrow tool-specific titles with broader functional roles.

Ensure expanded phrasing still matches actual scope.

4. Optimize Location Formatting

Use standardized city formatting.

Separate multi-location listings if needed.

Ensure remote roles are clearly marked.

5. Improve Early Scannability

Add bullet points in the intro section.

Move key responsibilities upward.

Reduce long, dense paragraphs.

6. Assess Visibility Levers

Evaluate sponsored budget competitiveness.

Check impression share against similar roles.

Consider reposting if aged.

7. Monitor Conversion Protection

After expanding reach, monitor ASR closely.

If ASR drops significantly, refine keyword breadth.`
          };
          const actionText = exportActionTexts[tileConfig.key] || tileConfig.recommendation || "";
          lines.push("");
          lines.push(csvEscape("Action Items"));
          lines.push("Type,Value");
          lines.push(`Tile,${csvEscape(tileConfig.title || "")}`);
          lines.push(`Action Text,${csvEscape(actionText)}`);
        }
        const csvText = lines.join("\n");
        const blob = new Blob([csvText], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();

        URL.revokeObjectURL(url);
      }

      function csvEscape(value) {
        const s = String(value);
        if (/[,"\n\r]/.test(s)) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      }

      function normalizeHeader(text) {
        return String(text || "")
          .replace(/^\uFEFF/, "")
          .trim()
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .replace(/[^a-z0-9]/g, "");
      }

      function pickHeader(headers, aliases) {
        const byNormalized = new Map();
        headers.forEach((h) => {
          const normalized = normalizeHeader(h);
          if (!byNormalized.has(normalized)) byNormalized.set(normalized, h);
        });
        for (const alias of aliases) {
          const normalizedAlias = normalizeHeader(alias);
          if (byNormalized.has(normalizedAlias)) return byNormalized.get(normalizedAlias);
        }
        return null;
      }

      function median(values) {
        if (!values.length) return null;
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) return (sorted[mid - 1] + sorted[mid]) / 2;
        return sorted[mid];
      }

      function niceMax(v) {
        if (v <= 0.05) return 0.05;
        if (v <= 0.1) return 0.1;
        if (v <= 0.2) return 0.2;
        if (v <= 0.5) return 0.5;
        return Math.ceil(v * 10) / 10;
      }

      function pctLabel(v) {
        return (v * 100).toFixed(1).replace(/\.0$/, "") + "%";
      }

      function intentColor(norm) {
        const n = Math.max(0, Math.min(1, norm));
        const r = Math.round(255 - 80 * n);
        const g = Math.round(230 - 120 * n);
        const b = Math.round(120 - 80 * n);
        return `rgb(${r},${g},${b})`;
      }

      function svgEl(tag, attrs, text) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        Object.entries(attrs || {}).forEach(([k, v]) => el.setAttribute(k, v));
        if (text != null) el.textContent = text;
        return el;
      }

      function escapeHTML(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function parseCSV(text) {
        const rows = [];
        let row = [];
        let cell = "";
        let inQuotes = false;

        for (let i = 0; i < text.length; i += 1) {
          const ch = text[i];
          const next = text[i + 1];

          if (inQuotes) {
            if (ch === '"' && next === '"') {
              cell += '"';
              i += 1;
            } else if (ch === '"') {
              inQuotes = false;
            } else {
              cell += ch;
            }
            continue;
          }

          if (ch === '"') {
            inQuotes = true;
            continue;
          }

          if (ch === ',') {
            row.push(cell);
            cell = "";
            continue;
          }

          if (ch === '\n') {
            row.push(cell.replace(/\r$/, ""));
            rows.push(row);
            row = [];
            cell = "";
            continue;
          }

          cell += ch;
        }

        if (cell.length || row.length) {
          row.push(cell.replace(/\r$/, ""));
          rows.push(row);
        }

        return rows.filter((r) => r.some((c) => String(c).trim() !== ""));
      }
    </script>
  </body>
</html>
