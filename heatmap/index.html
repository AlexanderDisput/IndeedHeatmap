<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indeed GeoViz - Ranked Performance Map</title>
    <link rel="icon" type="image/svg+xml" href="../favicon.svg" />
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --indeed-blue: #1f6fb2;
            --indeed-orange: #8b4aa8;
            --indeed-red: #d93025;
            --bg-light: #edf4ff;
            --glass-bg: rgba(255, 255, 255, 0.94);
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Sora', sans-serif;
            background:
              radial-gradient(circle at 10% 12%, #dce9ff 0%, transparent 35%),
              radial-gradient(circle at 85% 88%, #d9f0ff 0%, transparent 30%),
              var(--bg-light);
        }
        #map { height: 100vh; width: 100%; z-index: 1; }

        .table-panel {
            position: absolute; top: 8px; left: 8px; right: 8px; z-index: 1100;
            background: var(--glass-bg); border: 1px solid #d3e2f3; border-radius: 14px;
            box-shadow: 0 10px 20px rgba(18,34,53,0.14); overflow: hidden;
        }
        .table-panel-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 12px; background: #fff; border-bottom: 1px solid #e3edf8;
        }
        .table-panel-title { font-size: 13px; font-weight: 700; color: var(--indeed-blue); }
        .table-panel-controls { display: flex; align-items: center; gap: 8px; }
        .filter-chip { font-size: 11px; background: #edf5ff; color: #1f5d99; padding: 4px 8px; border-radius: 999px; }
        .table-content { max-height: 34vh; overflow: auto; background: #fff; }
        .table-panel.collapsed .table-content { display: none; }
        .table-panel.collapsed .table-panel-header { border-bottom: none; }
        .jobs-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .jobs-table th, .jobs-table td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; white-space: nowrap; }
        .jobs-table th { position: sticky; top: 0; background: #fbfbfb; z-index: 1; }
        .jobs-th-btn {
            appearance: none;
            border: 1px solid #002a70;
            background: #003A9B;
            color: #ffffff;
            border-radius: 8px;
            padding: 4px 8px;
            font: inherit;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: box-shadow 120ms ease, transform 120ms ease, background-color 120ms ease;
        }
        .jobs-th-btn:hover {
            background: #002f82;
            box-shadow: 0 4px 10px rgba(18, 34, 53, 0.16);
            transform: translateY(-1px);
        }
        .jobs-th-btn.active {
            background: #002f82;
        }

        .ui-panel {
            position: absolute; top: 72px; left: 8px; z-index: 1000;
            background: var(--glass-bg); padding: 18px; border-radius: 14px;
            box-shadow: 0 10px 20px rgba(18,34,53,0.14); width: 320px; border: 1px solid #d3e2f3;
        }

        button { background-color: var(--indeed-blue); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; }
        #applyPerformanceFilters,
        #toggleTableBtn {
            background: #003A9B;
            border: 1px solid #002a70;
            box-shadow: 0 2px 6px rgba(18, 34, 53, 0.14);
        }
        #applyPerformanceFilters:hover,
        #toggleTableBtn:hover {
            background: #002f82;
            box-shadow: 0 6px 14px rgba(18, 34, 53, 0.2);
        }
        
        .legend {
            margin-top: 15px; padding: 10px; background: #fff; border-radius: 8px; border: 1px solid #e3edf8;
        }
        .legend-bar {
            height: 10px; width: 100%;
            background: linear-gradient(to right, #d93025, #f6c343, #1a9850);
            margin-bottom: 5px; border-radius: 2px;
        }
        .legend-labels { display: flex; justify-content: space-between; font-size: 10px; font-weight: bold; color: #666; }

        .popup-card { min-width: 300px; max-width: 360px; }
        .popup-header {
            font-weight: 700;
            margin-bottom: 10px;
            border-bottom: 2px solid var(--indeed-blue);
            padding-bottom: 5px;
            font-size: 14px;
            color: #1f2d4f;
        }
        .popup-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }
        .popup-metric {
            margin: 0;
            background: #f8faff;
            border: 1px solid #e6edf8;
            border-radius: 8px;
            padding: 7px 8px;
        }
        .popup-label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            margin-bottom: 2px;
        }
        .popup-value {
            font-size: 13px;
            font-weight: 700;
            color: var(--indeed-blue);
            line-height: 1.25;
        }
        @media (max-width: 540px) {
            .popup-card { min-width: 220px; }
            .popup-grid { grid-template-columns: 1fr; }
        }
        .upload-status { font-size: 11px; margin-top: 8px; min-height: 14px; color: #444; }
        .upload-status.error { color: var(--indeed-red); }
        .upload-status.success { color: #137333; }
        .control-label { font-size: 12px; font-weight: bold; display: block; margin-bottom: 6px; }
        select { width: 100%; border: 1px solid #cddded; border-radius: 8px; padding: 7px; background: #fff; }
        .ghost-btn { background: #f3f8ff; color: #355275; border: 1px solid #d3e2f3; }
        .checkbox-row { display:flex; align-items:center; gap:8px; margin-top: 10px; font-size: 12px; color: #355275; font-weight: 700; }
        .checkbox-row input { width: 16px; height: 16px; accent-color: #003A9B; }
    </style>
</head>
<body>

<div id="map"></div>

<div id="tablePanel" class="table-panel collapsed">
    <div class="table-panel-header">
        <div id="tablePanelTitle" class="table-panel-title">Uploaded Jobs Table</div>
        <div class="table-panel-controls">
            <span id="tableFilterLabel" class="filter-chip">Showing all locations</span>
            <button id="clearTableFilter" class="ghost-btn" onclick="clearLocationFilter()" style="display:none;">Clear filter</button>
            <button onclick="toggleTablePanel()" id="toggleTableBtn">Show Table</button>
        </div>
    </div>
    <div class="table-content">
        <table class="jobs-table">
            <thead>
                <tr>
                    <th><button class="jobs-th-btn" data-sort-key="job">Job</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="city">City</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="impressions">Impressions</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="ctr">CTR</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="clicks">Clicks</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="asr">ASR</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="applyStarts">Apply starts</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="acr">ACR</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="applications">Applies</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="trafficIntent">Traffic intent</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="spend">Spend</button></th>
                    <th><button class="jobs-th-btn" data-sort-key="status">Status</button></th>
                </tr>
            </thead>
            <tbody id="jobsTableBody"></tbody>
        </table>
    </div>
</div>

<div class="ui-panel">
    <div>
        <label id="metricLabel" for="metricSelector" class="control-label">HEATMAP METRIC</label>
        <select id="metricSelector">
            <option value="apps">Applications</option>
            <option value="applyStarts">Application starts</option>
            <option value="clicks">Clicks</option>
            <option value="acr">Apply completion rate (ACR)</option>
            <option value="jobs">Job count</option>
            <option value="ctr">Click-through rate (CTR)</option>
            <option value="asr">Apply start rate (ASR)</option>
            <option value="intent">Traffic intent (CTR * ASR)</option>
        </select>
    </div>
    <div style="margin-top: 10px;">
        <label id="scaleLabel" for="scaleSelector" class="control-label">COLOR SCALE</label>
        <select id="scaleSelector">
            <option value="percentile">Percentile (P10-P90)</option>
            <option value="linear">Linear (min-max)</option>
            <option value="log">Logarithmic</option>
        </select>
    </div>
    <div style="margin-top: 10px;">
        <label id="viewModeLabel" for="viewModeSelector" class="control-label">VIEW MODE</label>
        <select id="viewModeSelector">
            <option value="total">Total</option>
            <option value="perJob">Per job</option>
        </select>
    </div>
    <label class="checkbox-row" for="clusterRingsToggle">
        <input id="clusterRingsToggle" type="checkbox" checked />
        <span id="clusterRingsLabel">Show area heat rings</span>
    </label>
    <div style="margin-top: 10px;">
        <label id="ctrFilterLabel" class="control-label">CTR FILTER</label>
        <div style="display:flex; gap:6px;">
            <select id="ctrFilterOp" style="width: 76px;">
                <option value="gte">&gt;</option>
                <option value="lte">&lt;</option>
            </select>
            <input id="ctrFilterValue" type="number" min="0" step="0.1" placeholder="e.g. 4.5" style="flex:1; border: 1px solid #cddded; border-radius: 8px; padding: 7px;">
        </div>
    </div>
    <div style="margin-top: 10px;">
        <label id="asrFilterLabel" class="control-label">ASR FILTER</label>
        <div style="display:flex; gap:6px;">
            <select id="asrFilterOp" style="width: 76px;">
                <option value="gte">&gt;</option>
                <option value="lte">&lt;</option>
            </select>
            <input id="asrFilterValue" type="number" min="0" step="0.1" placeholder="e.g. 12.0" style="flex:1; border: 1px solid #cddded; border-radius: 8px; padding: 7px;">
        </div>
    </div>
    <div style="margin-top: 10px;">
        <button id="applyPerformanceFilters" style="width:100%;">Apply CTR/ASR filter</button>
    </div>

    <div class="legend">
        <div class="legend-labels"><span id="legendLowLabel">LOW</span><span id="legendHighLabel">HIGH</span></div>
        <div class="legend-bar"></div>
        <p id="legendHelp" style="font-size: 11px; margin: 5px 0 0 0; color: #444;">Markers are colored by metric gradient.</p>
    </div>

    <div style="margin-top: 20px;">
        <label id="liveCsvLabel" style="font-size: 12px; font-weight: bold;">LIVE CSV UPDATE</label>
        <input type="file" id="csvUploader" accept=".csv" style="width:100%; margin-top:5px;">
        <div id="uploadStatus" class="upload-status">Expected Indeed columns (EN/NL/DE/FR/IT/ES): City/Plaats/Stadt/Ville/Citta/Ciudad, Country/Land/Pays/Paese/Pais, Impressions, Clicks/Clics/Klicks, Applications/Applies/Sollicitaties/Bewerbungen/Candidatures/Postulaciones, Apply starts/Gestarte sollicitaties/Begonnene Bewerbungen/Candidatures commencees/Candidature avviate/Postulaciones iniciadas</div>
    </div>

</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

<script>
    let map;
    let markersLayer = L.layerGroup();
    let clusterRingsLayer = L.layerGroup();
    const geocodeCache = {};
    const geocodeCacheKey = 'heatmap_geocode_cache_v1';
    const geocodeConcurrency = 8;
    let selectedMetric = 'apps';
    let selectedScale = 'percentile';
    let selectedViewMode = 'total';
    let showClusterRings = true;
    let lastRingData = [];
    let lastRingScale = null;
    let activeCityFilter = '';
    let uploadedJobRows = [];
    let tableSort = { key: "city", dir: "asc" };
    let appliedCtrFilter = { op: 'gte', value: null };
    let appliedAsrFilter = { op: 'gte', value: null };
    const gradientStops = { low: "#d93025", mid: "#f6c343", high: "#1a9850" };
    const embedded = new URLSearchParams(window.location.search).get("embedded") === "1";
    const SHARED_UPLOAD_MESSAGE = "shared-csv-upload";
    const UI_LANGUAGE_MESSAGE = "ui-language-changed";
    let currentLanguage = "en";
    const uiText = {
        en: {
            tableTitle: "Uploaded Jobs Table", showTable: "Show Table", hideTable: "Hide Table", clearFilter: "Clear filter",
            metric: "HEATMAP METRIC", scale: "COLOR SCALE", viewMode: "VIEW MODE", ctrFilter: "CTR FILTER", asrFilter: "ASR FILTER",
            applyFilter: "Apply CTR/ASR filter", liveCsv: "LIVE CSV UPDATE", clusterRings: "Show area heat rings"
        },
        de: {
            tableTitle: "Hochgeladene Jobs", showTable: "Tabelle anzeigen", hideTable: "Tabelle ausblenden", clearFilter: "Filter löschen",
            metric: "HEATMAP-METRIK", scale: "FARBSKALA", viewMode: "ANSICHT", ctrFilter: "CTR-FILTER", asrFilter: "ASR-FILTER",
            applyFilter: "CTR/ASR-Filter anwenden", liveCsv: "LIVE-CSV-UPDATE", clusterRings: "Flächen-Heat-Ringe anzeigen"
        },
        fr: {
            tableTitle: "Tableau des emplois importés", showTable: "Afficher le tableau", hideTable: "Masquer le tableau", clearFilter: "Effacer le filtre",
            metric: "MÉTRIQUE HEATMAP", scale: "ÉCHELLE DE COULEUR", viewMode: "MODE D'AFFICHAGE", ctrFilter: "FILTRE CTR", asrFilter: "FILTRE ASR",
            applyFilter: "Appliquer le filtre CTR/ASR", liveCsv: "MISE À JOUR CSV", clusterRings: "Afficher les anneaux de zone"
        },
        es: {
            tableTitle: "Tabla de empleos cargados", showTable: "Mostrar tabla", hideTable: "Ocultar tabla", clearFilter: "Borrar filtro",
            metric: "MÉTRICA HEATMAP", scale: "ESCALA DE COLOR", viewMode: "MODO DE VISTA", ctrFilter: "FILTRO CTR", asrFilter: "FILTRO ASR",
            applyFilter: "Aplicar filtro CTR/ASR", liveCsv: "ACTUALIZACIÓN CSV", clusterRings: "Mostrar anillos de zona"
        },
        it: {
            tableTitle: "Tabella lavori caricati", showTable: "Mostra tabella", hideTable: "Nascondi tabella", clearFilter: "Cancella filtro",
            metric: "METRICA HEATMAP", scale: "SCALA COLORE", viewMode: "MODALITÀ VISTA", ctrFilter: "FILTRO CTR", asrFilter: "FILTRO ASR",
            applyFilter: "Applica filtro CTR/ASR", liveCsv: "AGGIORNAMENTO CSV", clusterRings: "Mostra anelli area"
        },
        nl: {
            tableTitle: "Geüploade vacatures", showTable: "Tabel tonen", hideTable: "Tabel verbergen", clearFilter: "Filter wissen",
            metric: "HEATMAP-METRIEK", scale: "KLEURSCHAAL", viewMode: "WEERGAVE", ctrFilter: "CTR-FILTER", asrFilter: "ASR-FILTER",
            applyFilter: "CTR/ASR-filter toepassen", liveCsv: "LIVE CSV-UPDATE", clusterRings: "Toon gebieds-ringen"
        }
    };
    const tableHeaderI18n = {
        en: { job: "Job", city: "City", impressions: "Impressions", ctr: "CTR", clicks: "Clicks", asr: "ASR", applyStarts: "Apply starts", acr: "ACR", applications: "Applies", trafficIntent: "Traffic intent", spend: "Spend", status: "Status" },
        de: { job: "Job", city: "Stadt", impressions: "Impressionen", ctr: "CTR", clicks: "Klicks", asr: "ASR", applyStarts: "Bewerbungsstarts", acr: "ACR", applications: "Bewerbungen", trafficIntent: "Traffic-Intent", spend: "Ausgaben", status: "Status" },
        fr: { job: "Poste", city: "Ville", impressions: "Impressions", ctr: "CTR", clicks: "Clics", asr: "ASR", applyStarts: "Débuts candidature", acr: "ACR", applications: "Candidatures", trafficIntent: "Intention trafic", spend: "Dépenses", status: "Statut" },
        es: { job: "Puesto", city: "Ciudad", impressions: "Impresiones", ctr: "CTR", clicks: "Clics", asr: "ASR", applyStarts: "Inicios solicitud", acr: "ACR", applications: "Solicitudes", trafficIntent: "Intención tráfico", spend: "Gasto", status: "Estado" },
        it: { job: "Ruolo", city: "Città", impressions: "Impression", ctr: "CTR", clicks: "Clic", asr: "ASR", applyStarts: "Avvii candidatura", acr: "ACR", applications: "Candidature", trafficIntent: "Intento traffico", spend: "Spesa", status: "Stato" },
        nl: { job: "Vacature", city: "Plaats", impressions: "Impressies", ctr: "CTR", clicks: "Klikken", asr: "ASR", applyStarts: "Gestarte sollicitaties", acr: "ACR", applications: "Sollicitaties", trafficIntent: "Traffic intent", spend: "Uitgaven", status: "Status" }
    };
    const countryAliases = {
        deutschland: "Germany",
        deutschlande: "Germany",
        germany: "Germany",
        niederlande: "Netherlands",
        netherlands: "Netherlands",
        belgie: "Belgium",
        belgium: "Belgium"
    };
    
    const metricConfig = {
        apps: { label: "Applications", formatter: (v) => `${Math.round(v)}` },
        applyStarts: { label: "Application starts", formatter: (v) => `${Math.round(v)}` },
        clicks: { label: "Clicks", formatter: (v) => `${Math.round(v)}` },
        acr: { label: "Apply completion rate", formatter: (v) => `${(v * 100).toFixed(2)}%` },
        jobs: { label: "Job count", formatter: (v) => `${Math.round(v)}` },
        ctr: { label: "Click-through rate", formatter: (v) => `${(v * 100).toFixed(2)}%` },
        asr: { label: "Apply start rate", formatter: (v) => `${(v * 100).toFixed(2)}%` },
        intent: { label: "Traffic intent", formatter: (v) => `${(v * 100).toFixed(2)}%` }
    };
    const metricOptionOrder = ['apps', 'applyStarts', 'clicks', 'acr', 'jobs', 'ctr', 'asr', 'intent'];

    // Default data
    let campaignData = [
        {"name": "Drachten", "lat": 53.1125, "lng": 6.0989, "apps": 49, "impressions": 24662, "clicks": 1565, "cpa": 39.31, "jobs": 24, "spend": 1926.13},
        {"name": "Groningen", "lat": 53.2194, "lng": 6.5665, "apps": 39, "impressions": 18699, "clicks": 1212, "cpa": 17.42, "jobs": 10, "spend": 679.32},
        {"name": "Assen", "lat": 52.9925, "lng": 6.5642, "apps": 23, "impressions": 3171, "clicks": 373, "cpa": 6.55, "jobs": 3, "spend": 150.62},
        {"name": "Tolbert", "lat": 53.1667, "lng": 6.3667, "apps": 11, "impressions": 3705, "clicks": 227, "cpa": 13.36, "jobs": 2, "spend": 146.97},
        {"name": "Hoogeveen", "lat": 52.7214, "lng": 6.4919, "apps": 10, "impressions": 2106, "clicks": 158, "cpa": 15.1, "jobs": 4, "spend": 150.97},
        {"name": "Westerbroek", "lat": 53.1833, "lng": 6.6667, "apps": 5, "impressions": 4973, "clicks": 438, "cpa": 19.76, "jobs": 1, "spend": 98.81},
        {"name": "Hasselt", "lat": 52.5908, "lng": 6.0881, "apps": 3, "impressions": 1056, "clicks": 47, "cpa": 39.63, "jobs": 3, "spend": 118.9},
        {"name": "Drachtstercompagnie", "lat": 53.125, "lng": 6.1333, "apps": 2, "impressions": 1932, "clicks": 65, "cpa": 47.66, "jobs": 1, "spend": 95.31},
        {"name": "Heerenveen", "lat": 52.9575, "lng": 5.925, "apps": 2, "impressions": 4909, "clicks": 123, "cpa": 39.12, "jobs": 3, "spend": 78.25},
        {"name": "Roden", "lat": 53.1383, "lng": 6.425, "apps": 2, "impressions": 3848, "clicks": 291, "cpa": 40.04, "jobs": 1, "spend": 80.07},
        {"name": "Grootegast", "lat": 53.2133, "lng": 6.275, "apps": 1, "impressions": 3526, "clicks": 188, "cpa": 181.83, "jobs": 3, "spend": 181.83},
        {"name": "Kollum", "lat": 53.2833, "lng": 6.15, "apps": 1, "impressions": 2408, "clicks": 227, "cpa": 7.5, "jobs": 1, "spend": 7.5},
        {"name": "Veendam", "lat": 53.1, "lng": 6.8833, "apps": 1, "impressions": 154, "clicks": 8, "cpa": 18.29, "jobs": 1, "spend": 18.29},
        {"name": "Zuidbroek", "lat": 53.1667, "lng": 6.8667, "apps": 1, "impressions": 214, "clicks": 12, "cpa": 99.5, "jobs": 1, "spend": 99.5},
        {"name": "Joure", "lat": 52.9667, "lng": 5.7833, "apps": 0, "impressions": 52, "clicks": 5, "cpa": 0.0, "jobs": 2, "spend": 0.0},
        {"name": "Leek", "lat": 53.1611, "lng": 6.3925, "apps": 0, "impressions": 1721, "clicks": 106, "cpa": 0.0, "jobs": 2, "spend": 49.69},
        {"name": "Marum", "lat": 53.1417, "lng": 6.2611, "apps": 0, "impressions": 3431, "clicks": 227, "cpa": 0.0, "jobs": 1, "spend": 117.84}
    ];

    window.onload = function() {
        map = L.map('map').setView([53.1, 6.4], 9);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png').addTo(map);
        map.on('click', () => {
            // Background map click should only collapse the table, not clear the active city filter.
            setTableCollapsed(true);
        });
        map.on('zoomend', () => {
            if (!showClusterRings) return;
            renderClusterRings(lastRingData, lastRingScale);
        });
        campaignData = campaignData.map(enrichLocationMetrics);
        seedDefaultTableRows();
        renderMarkers();
        renderJobsTable();
        updateLegendBounds();
        document.getElementById('csvUploader').addEventListener('change', handleCsvUpload);
        document.getElementById('metricSelector').addEventListener('change', handleMetricChange);
        document.getElementById('scaleSelector').addEventListener('change', handleScaleChange);
        document.getElementById('viewModeSelector').addEventListener('change', handleViewModeChange);
        document.getElementById('applyPerformanceFilters').addEventListener('click', applyPerformanceFilters);
        document.getElementById('clusterRingsToggle').addEventListener('change', (event) => {
            showClusterRings = Boolean(event.target.checked);
            renderMarkers();
        });
        loadGeocodeCache();
        applyUiLanguage(currentLanguage);
        if (embedded) {
            const uploader = document.getElementById('csvUploader');
            const liveLabel = uploader && uploader.previousElementSibling;
            if (uploader) uploader.style.display = 'none';
            if (liveLabel) liveLabel.textContent = 'SHARED CSV UPDATE';
            setUploadStatus('Use the shared uploader in the top navigation to update this map.');
        }
    };

    function seedDefaultTableRows() {
        uploadedJobRows = campaignData.map((loc) => ({
            job: "Aggregated location data",
            city: loc.name,
            country: "",
            impressions: loc.impressions,
            ctr: loc.ctr,
            clicks: loc.clicks,
            applyStarts: loc.apps,
            acr: loc.apps > 0 ? 1 : 0,
            applications: loc.apps,
            asr: loc.asr,
            trafficIntent: loc.trafficIntent,
            spend: loc.spend,
            status: "-"
        }));
    }

    function toggleTablePanel() {
        const panel = document.getElementById('tablePanel');
        setTableCollapsed(!panel.classList.contains('collapsed'));
    }

    function setTableCollapsed(collapsed) {
        const panel = document.getElementById('tablePanel');
        panel.classList.toggle('collapsed', collapsed);
        const t = uiText[currentLanguage] || uiText.en;
        document.getElementById('toggleTableBtn').textContent = collapsed ? t.showTable : t.hideTable;
    }

    function applyUiLanguage(lang) {
        currentLanguage = uiText[lang] ? lang : "en";
        const t = uiText[currentLanguage];
        const set = (id, value) => { const el = document.getElementById(id); if (el) el.textContent = value; };
        set("tablePanelTitle", t.tableTitle);
        set("clearTableFilter", t.clearFilter);
        set("metricLabel", t.metric);
        set("scaleLabel", t.scale);
        set("viewModeLabel", t.viewMode);
        set("ctrFilterLabel", t.ctrFilter);
        set("asrFilterLabel", t.asrFilter);
        set("applyPerformanceFilters", t.applyFilter);
        set("liveCsvLabel", t.liveCsv);
        set("clusterRingsLabel", t.clusterRings);
        const panel = document.getElementById("tablePanel");
        const collapsed = panel ? panel.classList.contains("collapsed") : true;
        setTableCollapsed(collapsed);
        updateTableSortButtons();
        updateMetricSelectorOptions();
    }

    function clearLocationFilter() {
        activeCityFilter = '';
        renderJobsTable();
    }

    function handleMetricChange(event) {
        selectedMetric = event.target.value;
        renderMarkers();
        updateLegendBounds();
    }

    function handleScaleChange(event) {
        selectedScale = event.target.value;
        renderMarkers();
        updateLegendBounds();
    }

    function handleViewModeChange(event) {
        selectedViewMode = event.target.value;
        renderMarkers();
        updateLegendBounds();
    }

    function applyPerformanceFilters() {
        const ctrInputValue = document.getElementById('ctrFilterValue').value;
        const asrInputValue = document.getElementById('asrFilterValue').value;
        const ctrOp = document.getElementById('ctrFilterOp').value;
        const asrOp = document.getElementById('asrFilterOp').value;

        const ctrNumeric = Number(ctrInputValue);
        const asrNumeric = Number(asrInputValue);

        appliedCtrFilter = {
            op: ctrOp === 'lte' ? 'lte' : 'gte',
            value: ctrInputValue === '' || !Number.isFinite(ctrNumeric) ? null : ctrNumeric / 100
        };
        appliedAsrFilter = {
            op: asrOp === 'lte' ? 'lte' : 'gte',
            value: asrInputValue === '' || !Number.isFinite(asrNumeric) ? null : asrNumeric / 100
        };

        activeCityFilter = '';
        renderMarkers();
        renderJobsTable();
        updateLegendBounds();
    }

    function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
    }

    function hexToRgb(hex) {
        const safeHex = hex.replace('#', '');
        const value = parseInt(safeHex, 16);
        return { r: (value >> 16) & 255, g: (value >> 8) & 255, b: value & 255 };
    }

    function rgbToHex(r, g, b) {
        return `#${[r, g, b].map((x) => x.toString(16).padStart(2, '0')).join('')}`;
    }

    function blendColor(startHex, endHex, t) {
        const start = hexToRgb(startHex);
        const end = hexToRgb(endHex);
        return rgbToHex(
            Math.round(start.r + (end.r - start.r) * t),
            Math.round(start.g + (end.g - start.g) * t),
            Math.round(start.b + (end.b - start.b) * t)
        );
    }

    function gradientColorForValue(value, minValue, maxValue) {
        if (!Number.isFinite(value) || !Number.isFinite(minValue) || !Number.isFinite(maxValue) || minValue === maxValue) {
            return gradientStops.mid;
        }
        const ratio = clamp((value - minValue) / (maxValue - minValue), 0, 1);
        if (ratio < 0.5) return blendColor(gradientStops.low, gradientStops.mid, ratio / 0.5);
        return blendColor(gradientStops.mid, gradientStops.high, (ratio - 0.5) / 0.5);
    }

    function normalizeByJobs(value, jobs) {
        const safeJobs = Number(jobs || 0);
        if (!(safeJobs > 0)) return 0;
        return value / safeJobs;
    }

    function metricUsesPerJob(metricKey) {
        return metricKey === 'apps' || metricKey === 'applyStarts' || metricKey === 'clicks';
    }

    function getMetricSupportFlags() {
        const rows = Array.isArray(uploadedJobRows) && uploadedJobRows.length
            ? uploadedJobRows
            : campaignData.map((loc) => ({
                applications: Number(loc.apps || 0),
                applyStarts: Number(loc.applyStarts != null ? loc.applyStarts : loc.apps || 0),
                clicks: Number(loc.clicks || 0)
            }));

        const hasApplications = rows.some((row) => Number(row.applications || 0) > 0);
        const hasApplyStarts = rows.some((row) => Number(row.applyStarts || 0) > 0);
        return {
            apps: hasApplications,
            applyStarts: hasApplyStarts,
            clicks: true,
            acr: hasApplications && hasApplyStarts
        };
    }

    function buildMetricSelectorLabel(metricKey) {
        if (metricKey === 'apps') return 'Applications';
        if (metricKey === 'applyStarts') return 'Application starts';
        if (metricKey === 'clicks') return 'Clicks';
        if (metricKey === 'acr') return 'Apply completion rate (ACR)';
        if (metricKey === 'jobs') return 'Job count';
        if (metricKey === 'ctr') return 'Click-through rate (CTR)';
        if (metricKey === 'asr') return 'Apply start rate (ASR)';
        if (metricKey === 'intent') return 'Traffic intent (CTR * ASR)';
        return metricConfig[metricKey] ? metricConfig[metricKey].label : metricKey;
    }

    function updateMetricSelectorOptions() {
        const selector = document.getElementById('metricSelector');
        if (!selector) return;
        const support = getMetricSupportFlags();
        const allowedMetrics = metricOptionOrder.filter((metricKey) => {
            if (metricKey === 'apps') return support.apps;
            if (metricKey === 'acr') return support.acr;
            if (metricKey === 'clicks') return support.clicks;
            if (metricKey === 'applyStarts') return support.applyStarts;
            return true;
        });

        selector.innerHTML = allowedMetrics
            .map((metricKey) => `<option value="${metricKey}">${buildMetricSelectorLabel(metricKey)}</option>`)
            .join('');

        if (!allowedMetrics.includes(selectedMetric)) {
            selectedMetric = allowedMetrics.includes('applyStarts')
                ? 'applyStarts'
                : allowedMetrics.includes('jobs')
                    ? 'jobs'
                    : (allowedMetrics[0] || 'jobs');
        }
        selector.value = selectedMetric;
    }

    function getMetricValue(location, metricKey = selectedMetric) {
        let value = 0;
        if (metricKey === 'applyStarts') value = location.applyStarts || 0;
        else if (metricKey === 'clicks') value = location.clicks || 0;
        else if (metricKey === 'acr') value = location.acr || 0;
        else if (metricKey === 'jobs') value = location.jobs || 0;
        else if (metricKey === 'ctr') value = location.ctr || 0;
        else if (metricKey === 'asr') value = location.asr || 0;
        else if (metricKey === 'intent') value = location.trafficIntent || 0;
        else value = location.apps || 0;

        if (selectedViewMode === 'perJob' && metricUsesPerJob(metricKey)) {
            return normalizeByJobs(value, location.jobs);
        }
        return value;
    }

    function formatLegendValue(metricKey, value) {
        if (selectedViewMode === 'perJob' && metricUsesPerJob(metricKey)) {
            return `${value.toFixed(2)}/job`;
        }
        return metricConfig[metricKey].formatter(value);
    }

    function metricLabelForMode(metricKey) {
        const base = metricConfig[metricKey].label;
        if (selectedViewMode === 'perJob' && metricUsesPerJob(metricKey)) {
            return `${base} per job`;
        }
        return base;
    }

    function getCountryKey(location) {
        const country = String(location.country || '').trim();
        return country || 'Unknown';
    }

    function passesThreshold(value, filterConfig) {
        if (filterConfig.value == null || !Number.isFinite(filterConfig.value)) return true;
        if (!Number.isFinite(value)) return false;
        return filterConfig.op === 'lte' ? value <= filterConfig.value : value >= filterConfig.value;
    }

    function passesPerformanceFilter(location) {
        return passesThreshold(Number(location.ctr || 0), appliedCtrFilter) &&
            passesThreshold(Number(location.asr || 0), appliedAsrFilter);
    }

    function getFilteredCampaignData() {
        return campaignData.filter((loc) => passesPerformanceFilter(loc));
    }

    function percentile(sortedValues, p) {
        if (!sortedValues.length) return 0;
        const index = (sortedValues.length - 1) * p;
        const lower = Math.floor(index);
        const upper = Math.ceil(index);
        if (lower === upper) return sortedValues[lower];
        const weight = index - lower;
        return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;
    }

    function buildScaleInfo(values) {
        const clean = values.filter((v) => Number.isFinite(v));
        if (!clean.length) {
            return {
                low: 0, high: 1, mapValue: (v) => v, label: "linear", legendLow: 0, legendHigh: 0
            };
        }
        const sorted = [...clean].sort((a, b) => a - b);
        const min = sorted[0];
        const max = sorted[sorted.length - 1];

        if (selectedScale === 'log') {
            const tMin = Math.log1p(Math.max(min, 0));
            const tMax = Math.log1p(Math.max(max, 0));
            return {
                low: tMin,
                high: tMax,
                mapValue: (v) => Math.log1p(Math.max(v, 0)),
                label: "log",
                legendLow: min,
                legendHigh: max
            };
        }

        if (selectedScale === 'percentile') {
            let pLow = percentile(sorted, 0.1);
            let pHigh = percentile(sorted, 0.9);
            if (pLow === pHigh) {
                pLow = min;
                pHigh = max;
            }
            return {
                low: pLow,
                high: pHigh,
                mapValue: (v) => v,
                label: "P10-P90",
                legendLow: pLow,
                legendHigh: pHigh
            };
        }

        return {
            low: min,
            high: max,
            mapValue: (v) => v,
            label: "min-max",
            legendLow: min,
            legendHigh: max
        };
    }

    function haversineKm(aLat, aLng, bLat, bLng) {
        const toRad = (deg) => (deg * Math.PI) / 180;
        const dLat = toRad(bLat - aLat);
        const dLng = toRad(bLng - aLng);
        const lat1 = toRad(aLat);
        const lat2 = toRad(bLat);
        const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
        return 2 * 6371 * Math.asin(Math.sqrt(h));
    }

    function buildLocationClusters(locations, thresholdKm = 50) {
        const clusters = [];
        const visited = new Set();
        for (let i = 0; i < locations.length; i += 1) {
            if (visited.has(i)) continue;
            const queue = [i];
            visited.add(i);
            const idxs = [];
            while (queue.length) {
                const current = queue.shift();
                idxs.push(current);
                const base = locations[current];
                for (let j = 0; j < locations.length; j += 1) {
                    if (visited.has(j)) continue;
                    const other = locations[j];
                    const km = haversineKm(base.lat, base.lng, other.lat, other.lng);
                    if (km <= thresholdKm) {
                        visited.add(j);
                        queue.push(j);
                    }
                }
            }
            clusters.push(idxs.map((idx) => locations[idx]));
        }
        return clusters;
    }

    function getClusterMetricValue(cluster) {
        if (!Array.isArray(cluster) || !cluster.length) return 0;
        if (selectedMetric === 'ctr') {
            const impressions = cluster.reduce((sum, loc) => sum + Number(loc.impressions || 0), 0);
            const clicks = cluster.reduce((sum, loc) => sum + Number(loc.clicks || 0), 0);
            return impressions > 0 ? clicks / impressions : 0;
        }
        if (selectedMetric === 'asr') {
            const clicks = cluster.reduce((sum, loc) => sum + Number(loc.clicks || 0), 0);
            const applyStarts = cluster.reduce((sum, loc) => sum + Number(loc.applyStarts || 0), 0);
            return clicks > 0 ? applyStarts / clicks : 0;
        }
        if (selectedMetric === 'acr') {
            const applyStarts = cluster.reduce((sum, loc) => sum + Number(loc.applyStarts || 0), 0);
            const applications = cluster.reduce((sum, loc) => sum + Number(loc.apps || 0), 0);
            return applyStarts > 0 ? applications / applyStarts : 0;
        }
        if (selectedMetric === 'intent') {
            const impressions = cluster.reduce((sum, loc) => sum + Number(loc.impressions || 0), 0);
            const clicks = cluster.reduce((sum, loc) => sum + Number(loc.clicks || 0), 0);
            const applyStarts = cluster.reduce((sum, loc) => sum + Number(loc.applyStarts || 0), 0);
            const ctr = impressions > 0 ? clicks / impressions : 0;
            const asr = clicks > 0 ? applyStarts / clicks : 0;
            return ctr * asr;
        }
        if (selectedMetric === 'jobs') {
            return cluster.reduce((sum, loc) => sum + Number(loc.jobs || 0), 0);
        }
        if (selectedMetric === 'applyStarts') {
            if (selectedViewMode === 'perJob') {
                const starts = cluster.reduce((sum, loc) => sum + Number(loc.applyStarts || 0), 0);
                const jobs = cluster.reduce((sum, loc) => sum + Number(loc.jobs || 0), 0);
                return jobs > 0 ? starts / jobs : 0;
            }
            return cluster.reduce((sum, loc) => sum + Number(loc.applyStarts || 0), 0);
        }
        if (selectedMetric === 'clicks') {
            if (selectedViewMode === 'perJob') {
                const clicks = cluster.reduce((sum, loc) => sum + Number(loc.clicks || 0), 0);
                const jobs = cluster.reduce((sum, loc) => sum + Number(loc.jobs || 0), 0);
                return jobs > 0 ? clicks / jobs : 0;
            }
            return cluster.reduce((sum, loc) => sum + Number(loc.clicks || 0), 0);
        }
        if (selectedMetric === 'apps') {
            if (selectedViewMode === 'perJob') {
                const apps = cluster.reduce((sum, loc) => sum + Number(loc.apps || 0), 0);
                const jobs = cluster.reduce((sum, loc) => sum + Number(loc.jobs || 0), 0);
                return jobs > 0 ? apps / jobs : 0;
            }
            return cluster.reduce((sum, loc) => sum + Number(loc.apps || 0), 0);
        }
        return cluster.reduce((sum, loc) => sum + Number(getMetricValue(loc) || 0), 0);
    }

    function renderClusterRings(filteredData, referenceScale = null) {
        clusterRingsLayer.clearLayers();
        if (!showClusterRings || !Array.isArray(filteredData) || filteredData.length < 2) return;
        const clusters = buildLocationClusters(filteredData, 15).filter((cluster) => cluster.length > 1);
        if (!clusters.length) return;
        const clusterValues = clusters.map((cluster) => getClusterMetricValue(cluster));
        const scale = referenceScale || buildScaleInfo(clusterValues);
        const currentZoom = Number(map && typeof map.getZoom === 'function' ? map.getZoom() : 10);
        const zoomScale = Math.max(1, Math.min(2.6, 11 / Math.max(currentZoom, 1)));
        clusters.forEach((cluster, idx) => {
            const centroid = cluster.reduce((acc, loc) => {
                acc.lat += Number(loc.lat || 0);
                acc.lng += Number(loc.lng || 0);
                return acc;
            }, { lat: 0, lng: 0 });
            centroid.lat /= cluster.length;
            centroid.lng /= cluster.length;
            const value = clusterValues[idx];
            const scaledValue = scale.mapValue(value);
            const ringColor = gradientColorForValue(scaledValue, scale.low, scale.high);
            // Subtle flare: layered fill-only circles (opaque center -> transparent edge).
            const flareLayers = [
                { radius: Math.round(5000 * zoomScale), fillOpacity: 0.18 },
                { radius: Math.round(10000 * zoomScale), fillOpacity: 0.10 },
                { radius: Math.round(15000 * zoomScale), fillOpacity: 0.05 }
            ];
            flareLayers.forEach((layer) => {
                const ring = L.circle([centroid.lat, centroid.lng], {
                    radius: layer.radius,
                    stroke: false,
                    fillColor: ringColor,
                    fillOpacity: layer.fillOpacity,
                    interactive: false
                });
                clusterRingsLayer.addLayer(ring);
            });
        });
        clusterRingsLayer.addTo(map);
    }

    function enrichLocationMetrics(location) {
        const impressions = Number(location.impressions || 0);
        const clicks = Number(location.clicks || 0);
        const apps = Number(location.apps || 0);
        const applyStarts = Number(location.applyStarts != null ? location.applyStarts : apps);
        const spend = Number(location.spend || 0);
        const ctr = impressions > 0 ? clicks / impressions : 0;
        const asr = clicks > 0 ? applyStarts / clicks : 0;
        const acr = applyStarts > 0 ? apps / applyStarts : 0;
        const trafficIntent = ctr * asr;
        const cpa = apps > 0 ? spend / apps : Number(location.cpa || 0);
        return { ...location, impressions, clicks, apps, applyStarts, spend, ctr, asr, acr, trafficIntent, cpa };
    }

    function updateLegendBounds() {
        const filteredData = getFilteredCampaignData();
        if (!filteredData.length) {
            document.getElementById('legendLowLabel').textContent = 'NO DATA';
            document.getElementById('legendHighLabel').textContent = 'NO DATA';
            document.getElementById('legendHelp').textContent = 'No locations match the selected CTR/ASR filters.';
            return;
        }

        const metricLabel = metricLabelForMode(selectedMetric);
        const values = filteredData.map((loc) => getMetricValue(loc));
        const scale = buildScaleInfo(values);
        document.getElementById('legendLowLabel').textContent = `LOW ${formatLegendValue(selectedMetric, scale.legendLow)}`;
        document.getElementById('legendHighLabel').textContent = `HIGH ${formatLegendValue(selectedMetric, scale.legendHigh)}`;
        document.getElementById('legendHelp').textContent = `Markers use ${scale.label} scaling for ${metricLabel.toLowerCase()}.`;
    }

    function renderMarkers() {
        markersLayer.clearLayers();
        clusterRingsLayer.clearLayers();
        const filteredData = getFilteredCampaignData();
        const sortedData = [...filteredData].sort((a, b) => getMetricValue(a) - getMetricValue(b));
        if (!sortedData.length) return;
        const globalScale = buildScaleInfo(sortedData.map((loc) => getMetricValue(loc)));
        lastRingData = sortedData;
        lastRingScale = globalScale;
        renderClusterRings(sortedData, globalScale);

        sortedData.forEach((loc) => {
            const activeScale = globalScale;
            const scaledValue = activeScale.mapValue(getMetricValue(loc));
            const markerColor = gradientColorForValue(scaledValue, activeScale.low, activeScale.high);
            const perJobMode = selectedViewMode === 'perJob';
            const appLabel = perJobMode ? 'Applications/job' : 'Applications';
            const applyStartLabel = perJobMode ? 'Application starts/job' : 'Application starts';
            const impressionsLabel = perJobMode ? 'Impressions/job' : 'Impressions';
            const clicksLabel = perJobMode ? 'Clicks/job' : 'Clicks';
            const spendLabel = perJobMode ? 'Spend/job' : 'Spend';
            const appValue = perJobMode ? normalizeByJobs(loc.apps, loc.jobs).toFixed(2) : loc.apps;
            const applyStartValue = perJobMode ? normalizeByJobs(loc.applyStarts, loc.jobs).toFixed(2) : loc.applyStarts;
            const impressionsValue = perJobMode ? normalizeByJobs(loc.impressions, loc.jobs).toFixed(2) : loc.impressions.toLocaleString();
            const clicksValue = perJobMode ? normalizeByJobs(loc.clicks, loc.jobs).toFixed(2) : loc.clicks;
            const spendValue = perJobMode ? normalizeByJobs(loc.spend, loc.jobs).toFixed(2) : loc.spend.toFixed(2);
            const marker = L.circleMarker([loc.lat, loc.lng], {
                radius: 8,
                fillColor: markerColor,
                color: "#ffffff",
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            });

            const popupContent = `
                <div class="popup-card">
                    <div class="popup-header" style="border-bottom-color:${markerColor};">${loc.name}</div>
                    <div class="popup-grid">
                        <div class="popup-metric"><div class="popup-label">${appLabel}</div><div class="popup-value">${appValue}</div></div>
                        <div class="popup-metric"><div class="popup-label">${applyStartLabel}</div><div class="popup-value">${applyStartValue}</div></div>
                        <div class="popup-metric"><div class="popup-label">${impressionsLabel}</div><div class="popup-value">${impressionsValue}</div></div>
                        <div class="popup-metric"><div class="popup-label">${clicksLabel}</div><div class="popup-value">${clicksValue}</div></div>
                        <div class="popup-metric"><div class="popup-label">CTR</div><div class="popup-value">${(loc.ctr * 100).toFixed(2)}%</div></div>
                        <div class="popup-metric"><div class="popup-label">ASR</div><div class="popup-value">${(loc.asr * 100).toFixed(2)}%</div></div>
                        <div class="popup-metric"><div class="popup-label">Traffic intent</div><div class="popup-value">${(loc.trafficIntent * 100).toFixed(2)}%</div></div>
                        <div class="popup-metric"><div class="popup-label">Cost per application</div><div class="popup-value">€${loc.cpa.toFixed(2)}</div></div>
                        <div class="popup-metric"><div class="popup-label">Jobs</div><div class="popup-value">${loc.jobs}</div></div>
                        <div class="popup-metric"><div class="popup-label">${spendLabel}</div><div class="popup-value">€${spendValue}</div></div>
                    </div>
                </div>
            `;

            marker.bindPopup(popupContent, { maxWidth: 390 });
            marker.on('click', () => {
                activeCityFilter = loc.name;
                renderJobsTable();
                setTableCollapsed(false);
            });
            markersLayer.addLayer(marker);
        });

        markersLayer.addTo(map);

        if (sortedData.length > 0) {
            const bounds = L.latLngBounds(sortedData.map((loc) => [loc.lat, loc.lng]));
            map.fitBounds(bounds, { padding: [25, 25], maxZoom: 11 });
        }
    }

    function escapeHtml(value) {
        return String(value || '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    function visibleTableRows() {
        const baseRows = uploadedJobRows.filter((row) => passesPerformanceFilter(row));
        if (!activeCityFilter) return baseRows;
        return baseRows.filter((row) => row.city === activeCityFilter);
    }

    function getTableSortValue(row, key) {
        if (key === 'job' || key === 'city' || key === 'status') return String(row[key] || '');
        return Number(row[key] || 0);
    }

    function updateTableSortButtons() {
        const labels = tableHeaderI18n[currentLanguage] || tableHeaderI18n.en;
        document.querySelectorAll('.jobs-th-btn').forEach((btn) => {
            const key = btn.dataset.sortKey;
            const active = key === tableSort.key;
            btn.classList.toggle('active', active);
            const base = labels[key] || btn.textContent.replace(/\s*[↑↓]$/, '');
            btn.textContent = active ? `${base} ${tableSort.dir === 'asc' ? '↑' : '↓'}` : base;
        });
    }

    function renderJobsTable() {
        const rows = visibleTableRows().slice().sort((a, b) => {
            const av = getTableSortValue(a, tableSort.key);
            const bv = getTableSortValue(b, tableSort.key);
            const dir = tableSort.dir === 'asc' ? 1 : -1;
            if (typeof av === 'string' || typeof bv === 'string') return String(av).localeCompare(String(bv)) * dir;
            return (Number(av) - Number(bv)) * dir;
        });
        const body = document.getElementById('jobsTableBody');
        const clearBtn = document.getElementById('clearTableFilter');
        const filterLabel = document.getElementById('tableFilterLabel');
        updateTableSortButtons();

        filterLabel.textContent = activeCityFilter ? `Filtered: ${activeCityFilter}` : 'Showing all locations';
        filterLabel.style.cursor = activeCityFilter ? 'pointer' : 'default';
        filterLabel.onclick = activeCityFilter ? clearLocationFilter : null;
        clearBtn.style.display = activeCityFilter ? 'inline-block' : 'none';

        if (!rows.length) {
            body.innerHTML = `<tr><td colspan="12">No rows for current filter.</td></tr>`;
            return;
        }

        body.innerHTML = rows.map((row) => `
            <tr>
                <td>${escapeHtml(row.job)}</td>
                <td>${escapeHtml(row.city)}</td>
                <td>${Number(row.impressions || 0).toLocaleString()}</td>
                <td>${(Number(row.ctr || 0) * 100).toFixed(2)}%</td>
                <td>${Number(row.clicks || 0).toLocaleString()}</td>
                <td>${(Number(row.asr || 0) * 100).toFixed(2)}%</td>
                <td>${Number(row.applyStarts || 0).toLocaleString()}</td>
                <td>${(Number(row.acr || 0) * 100).toFixed(2)}%</td>
                <td>${Number(row.applications || 0).toLocaleString()}</td>
                <td>${(Number(row.trafficIntent || 0) * 100).toFixed(2)}%</td>
                <td>€${Number(row.spend || 0).toFixed(2)}</td>
                <td>${escapeHtml(row.status || "-")}</td>
            </tr>
        `).join('');
    }

    function normalizeHeader(header) {
        return String(header || '')
            .replace(/^\uFEFF/, '')
            .trim()
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-z0-9]/g, '');
    }

    function parseNumber(value, fallback = 0) {
        const cleaned = String(value || '').replace(',', '.').trim();
        if (!cleaned) return fallback;
        const parsed = Number(cleaned);
        return Number.isFinite(parsed) ? parsed : fallback;
    }

    function getField(row, aliases, required = false) {
        const key = Object.keys(row).find((k) => aliases.includes(normalizeHeader(k)));
        const value = key ? row[key] : '';
        if (required && String(value || '').trim() === '') return null;
        return value;
    }

    function hasAnyHeader(headers, aliases) {
        return aliases.some((alias) => headers.includes(alias));
    }

    function parseCampaignRows(rows) {
        const parsed = [];
        const skipped = [];

        rows.forEach((row, rowIndex) => {
            const name = getField(row, ['name', 'location', 'city', 'plaats'], true);
            const lat = parseNumber(getField(row, ['lat', 'latitude'], true), NaN);
            const lng = parseNumber(getField(row, ['lng', 'lon', 'long', 'longitude'], true), NaN);

            if (!name || !Number.isFinite(lat) || !Number.isFinite(lng)) {
                skipped.push(rowIndex + 2);
                return;
            }

            parsed.push({
                name: String(name).trim(),
                lat,
                lng,
                apps: parseNumber(getField(row, ['apps', 'applications', 'applies']), 0),
                impressions: parseNumber(getField(row, ['impressions', 'views']), 0),
                clicks: parseNumber(getField(row, ['clicks']), 0),
                cpa: parseNumber(getField(row, ['cpa', 'costperapplication']), 0),
                jobs: parseNumber(getField(row, ['jobs', 'vacancies']), 0),
                spend: parseNumber(getField(row, ['spend', 'cost']), 0)
            });
        });

        return { parsed, skipped };
    }

    function parseIndeedJobRows(rows) {
        const parsed = [];
        const skipped = [];

        rows.forEach((row, rowIndex) => {
            const cityRaw = getField(row, ['city', 'plaats', 'stadt', 'ville', 'citta', 'ciudad'], true);
            if (!cityRaw) {
                skipped.push(rowIndex + 2);
                return;
            }
            const country = String(getField(row, ['country', 'land', 'pays', 'paese', 'pais'], false) || '').trim();
            const region = String(getField(row, ['countyregion', 'region', 'state', 'province', 'provincieregio', 'bundeslandregion', 'departementregion', 'regioneprovincia', 'estadoregion'], false) || '').trim();
            const impressions = parseNumber(getField(row, ['impressions', 'impressies', 'visualizzazioni', 'impresiones']), 0);
            const clicks = parseNumber(getField(row, ['clicks', 'kliks', 'klicks', 'clics', 'click']), 0);
            const applyStarts = parseNumber(getField(row, ['applystarts', 'gestartesollicitaties', 'begonnenebewerbungen', 'candidaturescommencees', 'candidatureavviate', 'postulacionesiniciadas']), 0);
            const applications = parseNumber(getField(row, ['applications', 'applies', 'sollicitaties', 'bewerbungen', 'candidatures', 'postulaciones']), 0);
            let acr = parseNumber(getField(row, ['applycompletionrateacr', 'acr', 'tauxdecandidaturetermineeacr', 'sollicitatievoltooiingspercentageacr', 'abschlussratebewerbungacr', 'percentualedicompletamentocandidaturaacr', 'tasadefinalizaciondesolicitudacr']), NaN);
            const spend = parseNumber(getField(row, ['spend', 'besteding', 'ausgaben', 'depenses', 'spesa', 'gasto']), 0);

            let ctr = parseNumber(getField(row, ['clickthroughratectr', 'ctr', 'tauxdeclicksctr', 'percentualediclickctr', 'porcentajedeclicspc']), NaN);
            if (!Number.isFinite(ctr)) ctr = impressions > 0 ? clicks / impressions : 0;
            if (ctr > 1) ctr /= 100;

            let asr = parseNumber(getField(row, ['applystartrateasr', 'asr', 'percentagegestartesollicitaties', 'ratebegonnenerbewerbungenasr', 'tauxdecandidaturescommenceesasr', 'percentualedicandidatureavviatepca', 'porcentajedepostulacionesiniciadasppi']), NaN);
            if (!Number.isFinite(asr)) asr = clicks > 0 ? applyStarts / clicks : 0;
            if (asr > 1) asr /= 100;
            if (!Number.isFinite(acr)) acr = applyStarts > 0 ? applications / applyStarts : 0;
            if (acr > 1) acr /= 100;

            parsed.push({
                job: String(getField(row, ['job', 'vacature', 'stelle', 'emploi', 'annuncio', 'empleo'], false) || 'Unknown job').trim(),
                city: String(cityRaw).trim(),
                country,
                region,
                impressions,
                clicks,
                applyStarts,
                applications,
                ctr,
                asr,
                acr,
                trafficIntent: ctr * asr,
                spend,
                status: String(getField(row, ['jobstatus', 'vacaturestatus', 'status', 'statusderstellenanzeige', 'statutdelemploi', 'statodellannuncio', 'estadodelempleo'], false) || '-').trim()
            });
        });

        return { parsed, skipped };
    }

    function aggregateIndeedRows(jobRows) {
        const byCity = new Map();
        jobRows.forEach((job) => {
            const key = `${job.city.toLowerCase()}|${job.country.toLowerCase()}`;

            if (!byCity.has(key)) {
                byCity.set(key, {
                    name: job.city,
                    country: job.country,
                    region: job.region,
                    lat: NaN,
                    lng: NaN,
                    apps: 0,
                    applyStarts: 0,
                    impressions: 0,
                    clicks: 0,
                    jobs: 0,
                    spend: 0
                });
            }

            const entry = byCity.get(key);
            entry.apps += job.applications;
            entry.applyStarts += job.applyStarts;
            entry.impressions += job.impressions;
            entry.clicks += job.clicks;
            entry.spend += job.spend;
            entry.jobs += 1;
        });

        const aggregated = Array.from(byCity.values()).map((entry) => {
            const ctr = entry.impressions > 0 ? entry.clicks / entry.impressions : 0;
            const asr = entry.clicks > 0 ? entry.applyStarts / entry.clicks : 0;
            const acr = entry.applyStarts > 0 ? entry.apps / entry.applyStarts : 0;
            return {
                ...entry,
                apps: entry.apps,
                ctr,
                asr,
                acr,
                trafficIntent: ctr * asr,
                cpa: entry.apps > 0 ? entry.spend / entry.apps : 0
            };
        });

        return aggregated;
    }

    async function geocodeLocation(queryText) {
        const cacheKey = String(queryText || '').toLowerCase();
        if (geocodeCache[cacheKey]) return geocodeCache[cacheKey];

        try {
            const query = encodeURIComponent(queryText);
            const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${query}`;
            const response = await fetch(url, { headers: { 'Accept-Language': 'en' } });
            if (!response.ok) return null;
            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) return null;
            const point = { lat: Number(data[0].lat), lng: Number(data[0].lon) };
            if (!Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return null;
            geocodeCache[cacheKey] = point;
            saveGeocodeCache();
            return point;
        } catch {
            return null;
        }
    }

    function loadGeocodeCache() {
        try {
            const raw = localStorage.getItem(geocodeCacheKey);
            if (!raw) return;
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== 'object') return;
            Object.keys(parsed).forEach((key) => {
                const entry = parsed[key];
                if (entry && Number.isFinite(entry.lat) && Number.isFinite(entry.lng)) {
                    geocodeCache[key] = { lat: Number(entry.lat), lng: Number(entry.lng) };
                }
            });
        } catch {
            // no-op if localStorage is unavailable
        }
    }

    function saveGeocodeCache() {
        try {
            localStorage.setItem(geocodeCacheKey, JSON.stringify(geocodeCache));
        } catch {
            // no-op if localStorage is unavailable
        }
    }

    function normalizeCountryName(rawCountry) {
        const cleaned = String(rawCountry || '').trim();
        const key = cleaned.toLowerCase();
        return countryAliases[key] || cleaned;
    }

    async function resolveLocationCoordinate(loc) {
        const normalizedCountry = normalizeCountryName(loc.country || '');
        const searchQueries = [
            [loc.name, loc.region, normalizedCountry].filter(Boolean).join(', '),
            [loc.name, normalizedCountry].filter(Boolean).join(', '),
            loc.name
        ];

        for (const query of searchQueries) {
            const point = await geocodeLocation(query);
            if (point) return point;
        }
        return null;
    }

    async function enrichWithCoordinates(locations, onProgress) {
        const unresolved = [];
        const total = locations.length;
        let completed = 0;
        let nextIndex = 0;
        const workerCount = Math.max(1, Math.min(geocodeConcurrency, total));

        const workers = Array.from({ length: workerCount }, async () => {
            while (true) {
                const currentIndex = nextIndex;
                nextIndex += 1;
                if (currentIndex >= total) return;

                const loc = locations[currentIndex];
                if (!Number.isFinite(loc.lat) || !Number.isFinite(loc.lng)) {
                    const point = await resolveLocationCoordinate(loc);
                    if (point) {
                        loc.lat = point.lat;
                        loc.lng = point.lng;
                    } else {
                        unresolved.push(loc.name);
                    }
                }

                completed += 1;
                if (typeof onProgress === 'function') onProgress(completed, total);
            }
        });

        await Promise.all(workers);

        return unresolved;
    }

    function setUploadStatus(message, type = '') {
        const status = document.getElementById('uploadStatus');
        status.textContent = message;
        status.className = `upload-status${type ? ` ${type}` : ''}`;
    }

    async function processParsedRows(rows, sourceLabel) {
        const firstRow = rows[0] || {};
        const headers = Object.keys(firstRow).map((h) => normalizeHeader(h));
        const hasCity = hasAnyHeader(headers, ['city', 'plaats', 'stadt', 'ville', 'citta', 'ciudad']);
        const hasCountry = hasAnyHeader(headers, ['country', 'land', 'pays', 'paese', 'pais']);
        const hasImpressions = hasAnyHeader(headers, ['impressions', 'impressies', 'visualizzazioni', 'impresiones']);
        const isIndeedStructure = hasCity && hasCountry && hasImpressions;
        let parsed = [];
        let skipped = [];

        if (isIndeedStructure) {
            const indeedParsed = parseIndeedJobRows(rows);
            skipped = indeedParsed.skipped;
            uploadedJobRows = indeedParsed.parsed;
            parsed = aggregateIndeedRows(uploadedJobRows);
        } else {
            const manualParsed = parseCampaignRows(rows);
            parsed = manualParsed.parsed.map(enrichLocationMetrics);
            skipped = manualParsed.skipped;
            uploadedJobRows = parsed.map((loc) => ({
                job: "Uploaded location row",
                city: loc.name,
                country: loc.country || "",
                impressions: loc.impressions || 0,
                ctr: loc.ctr || 0,
                clicks: loc.clicks || 0,
                applyStarts: loc.applyStarts || loc.apps || 0,
                acr: (loc.applyStarts || loc.apps || 0) > 0 ? (loc.apps || 0) / (loc.applyStarts || loc.apps || 0) : 0,
                applications: loc.apps || 0,
                asr: loc.asr || 0,
                trafficIntent: loc.trafficIntent || 0,
                spend: loc.spend || 0,
                status: "-"
            }));
        }

        if (!parsed.length || !uploadedJobRows.length) {
            setUploadStatus('No valid rows found. Required fields: City and Country (Indeed export) or name/location + lat/lng.', 'error');
            return;
        }

        setUploadStatus(`Parsed ${parsed.length} location(s). Resolving coordinates (0/${parsed.length})...`);
        const unresolved = await enrichWithCoordinates(parsed, (done, total) => {
            setUploadStatus(`Parsed ${total} location(s). Resolving coordinates (${done}/${total})...`);
        });
        const resolvedData = parsed.filter((loc) => Number.isFinite(loc.lat) && Number.isFinite(loc.lng));
        const unresolvedUnique = Array.from(new Set(unresolved.map((name) => String(name || '').trim()).filter(Boolean)));

        if (!resolvedData.length) {
            setUploadStatus('Could not resolve any coordinates. Check City/Country values or internet connection.', 'error');
            return;
        }

        activeCityFilter = '';
        tableSort = { key: "city", dir: "asc" };
        campaignData = resolvedData;
        updateMetricSelectorOptions();
        renderMarkers();
        renderJobsTable();
        updateLegendBounds();

        if (unresolvedUnique.length || skipped.length) {
            const parts = [`Loaded ${resolvedData.length} location(s) from ${sourceLabel}.`];
            if (skipped.length) parts.push(`Skipped rows: ${skipped.length}.`);
            if (unresolvedUnique.length) {
                parts.push(`Unresolved locations: ${unresolvedUnique.slice(0, 5).join(', ')}${unresolvedUnique.length > 5 ? '...' : ''}.`);
            }
            setUploadStatus(parts.join(' '), 'error');
            return;
        }

        setUploadStatus(`Loaded ${resolvedData.length} location(s) from ${sourceLabel}.`, 'success');
    }

    function handleCsvUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        setUploadStatus(`Parsing ${file.name}...`);

        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: async (results) => {
                await processParsedRows(results.data || [], file.name);
            },
            error: () => {
                setUploadStatus('Could not parse CSV. Please verify the file format.', 'error');
            }
        });
    }

    function handleSharedCsvUpload(text, sourceLabel) {
        setUploadStatus(`Parsing ${sourceLabel}...`);
        Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            complete: async (results) => {
                await processParsedRows(results.data || [], sourceLabel);
            },
            error: () => {
                setUploadStatus('Could not parse shared CSV. Please verify the file format.', 'error');
            }
        });
    }

    window.addEventListener("message", (event) => {
        const data = event.data;
        if (!data) return;
        if (data.type === SHARED_UPLOAD_MESSAGE && data.payload && data.payload.text) {
            handleSharedCsvUpload(data.payload.text, `shared file ${data.payload.name || "CSV"}`);
            return;
        }
        if (data.type === UI_LANGUAGE_MESSAGE && data.payload && data.payload.language) {
            applyUiLanguage(data.payload.language);
        }
    });

    document.querySelectorAll('.jobs-th-btn').forEach((btn) => {
        btn.addEventListener('click', () => {
            const key = btn.dataset.sortKey;
            if (tableSort.key === key) {
                tableSort.dir = tableSort.dir === 'asc' ? 'desc' : 'asc';
            } else {
                tableSort.key = key;
                tableSort.dir = key === 'job' || key === 'city' || key === 'status' ? 'asc' : 'desc';
            }
            renderJobsTable();
        });
    });

    // Keep selector options in sync with available metrics for default demo state.
    updateMetricSelectorOptions();

</script>
</body>
</html>
